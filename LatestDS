 sra-internships@sisa.samsung.com
SRA Resume Submission
Link to DP questions -
https://www.quora.com/What-are-the-top-10-most-popular-dynamic-programming-problems- among-interviewers
------------------------------------------------------------------
//In this take two pointers, incr 1 by one and 2 by two and keep chckng for data if equal //loop exists
//
//​http://www.geeksforgeeks.org/detect-and-remove-loop-in-a-linked-list/
public void detectLoop(Node head){
if(head == null) return;
Node curr = head;
Node incrByTwo = head;
while(incrByTwo != null && incrByTwo.next!=null){
incrByTwo=incrByTwo.next.next; curr = curr.next;
if(curr.data == incrByTwo.data){
System.out.println("Loop Exists");
break; }
if(incrByTwo==null|| incrByTwo.next==null){ System.out.println("Loop doesnt Exists"); return;
} }
/* If loop exists */
if (curr == incrByTwo) {
curr = node;
while (curr != incrByTwo.next) {
curr = curr.next;
incrByTwo = incrByTwo.next; }
/* since incrByTwo>next is the looping point */ incrByTwo.next = null; /* remove loop */
}
    ​loop @ 15
 slow 50
 fast 15
 slow 20
 fast 4
 Linked List after removing loop :
 50 20 15 4 10
 
 }
------------------------------------------------------------------ public void middleElement(Node head){
if(head == null)return;
Node curr = head;
Node incrByTwo = head.next; while(incrByTwo!=null || incrByTwo.next!=null){
cur= cur.next;
incrByTwo = incrByTwo.next.next; }
System.out.println("The middle element is :"+curr.data); }
------------------------------------------------------------------ public void reverseLinkList(Node head){
if(head == null)return; Node prevNode = null; Node nextNode;
Node current = head; while(current!=null){
nextNode = current.next; current.next = prevNode; prevNode = current; current = nextNode;
} }
------------------------------------------------------------------ /*recursive
Output of this program will be same as above program. Now lets understand logic for above recursive program. 5->6->7->1->2
below function will terminate when last node(2) 's next will be null.so while returning when you reach at node with value 1,If you closely observe​ node.next.next=node​​ is actually setting 2->1(i.e. reversing the link between node with value 1 and 2) and ​node.next=null ​​is removing link 1->2. So in each iteration, you are reversing link between two nodes.
Below diagram will make it clear
Read more at http://www.java2blog.com/2014/07/how-to-reverse-linked-list-in-java.html#BX0W7k4YOG4U olyV.99
*/
public static Node reverseLinkedList(Node node) {
if (node == null || node.next == null) { return node;
   
 }
Node remaining = reverseLinkedList(node.next); node.next.next = node;
node.next = null;
return remaining; }
------------------------------------------------------------------
public void removeDupLinkList(Node head){ if(head == null)return;
Node current = head;
while(current.next != null){
if(current.next.data == current.data){ current.next = current.next.next;
}
else current = current.next; }
} ------------------------------------------------------------------ public void removeDupLinkHashmap(Node head){
if(head == null)return;
} ------------------------------------------------------------------
/*Mergesort for the linklist
link - http://www.sanfoundry.com/java-program-implement-merge-sort-algorithm-linked-list/*/ public Node mergeSortLinkList(Node head){
if(head==null || head.next == null) return head;
a = head;
b = head.next;
while(b!=null && b.next!=null){ //**Finding the middle element of the linkList
head = head.next;
b = b.next.next; }
b = head.next; //middle element of the link list
head.next = null;//settng it to null again to move to loop again. merge(mergeSortLinkList(a),(mergeSortLinkList(b));
}
public Node merge(Node a , Node b){
Node temp = new Node(); Node head = temp;
Node c = head; while(a!=null && b!= null){

 if(a.data <= b.data){ //comparing the data in linklist
c.next = a; //this 3 statement replaces the less value with the higher, so that they are
at correct position. Storing the address stored in of next element in “a” to “c” c = a; //copying a to c
a = a.next; }
else{
c.next = b; //this 3 statement replaces the less value with the higher, so that they are
correct position. c = b;
b = b.next; }
}
c.next = (a == null) ? b : a; //if any extra ones then in dat case again copy to c return head.next;
}
------------------------------------------------------------------
/* towerofhanoi, declare array of stack and den move from 1 to 3, 1 to 2 and den back to 2. Repeat dis recursivley until ol disk unstacked from 1
link - http://www.sanfoundry.com/java-program-implement-solve-tower-of-hanoi-using-stacks/*/ class towerofhanoi{
Stack<Integer> tower[] = new Stack<Integer>[3];
public static void main(String args[]){ System.out.println("Enter the number of disks"); Scanner kbd = new Scanner(System.in);
int n = kbd.nextInt();
tower[1] = new Stack<Integer>();
tower[2] = new Stack<Integer>();
tower[3] = new Stack<Integer>();
towerH(n);
}
public void towerH(int n){ //n - number of disks
for(int i = n; i > 0; i--) tower[1].push(i); move(n,1,2,3);
}
public void move(int n, int a, int b, int c){
if(n > 0){
move(n-1,a,c,b); tower[c].push(tower[a].pop()); move(n-1,b,a,c)
}
}

 }
------------------------------------------------------------------
/* Intersection of link list. First calculate the length of two lists and find the difference. Then start from the longer list at the diff offset, iterate through 2 lists and find the node.
A: a1 -> a2
->
c1 -> c2 -> c3
->
B: b1->b2->b3
link - ​http://www.programcreek.com/2014/02/leetcode-intersection-of-two-linked-lists-java/ (Note that getting a common node is done by comparing the address of the nodes)(Note that getting a common node is done by comparing the address of the nodes)​*/
public Node intersectionOfList (Node headA, Node headB){
Node p1, p2;
p1 = headA;
p2 = headB;
int len1, len2;
if(p1 == null || p2 == null){
return null; }
while(p1.next != null){ len1++;
p1 = p1.next; }
while(p2.next != null){ len2++;
p2 = p2.next; }
int diff;
p1 = headA; p2 = headB;
if(len1 > len2){
diff = len1 - len2
int i = 0;
while(i < diff){//bring to same position.
p1 = p1.next;
i++; }
} else{
diff = len2 - len1; int i = 0;
while(i < diff){
p2 = p2.next;
 
 i++; }
}
while(p1 != null && p2 != null){ /*this is the reason we move it by difference and den put a && condition here in the while loop. Because we wont know den when to END condition for the while loop, hence the above diff value.*/
if(p1.val == p2.val) return p1;
p1 = p1.next;
p2 = p2.next; }
return null; }
------------------------------------------------------------------ class Stack{
int top=-1, size, len=0;
int array[];
Scanner kbd = new Scanner(System.in); size = kbd.nextInt();
array = new [size];
boolean isEmpty(){ return top == -1;
}
void push(int data){ if(!isEmpty()){ arr[top++] = data; len++;
}
else new IndexOutOfBoundsException("Overflow Exception"); //important to throw an exception from the point of interview as well.
}
int pop(){
if(!isEmpty()){ len--;
return arr[top--]; }
}
int min(){
if(){
} }

 }
------------------------------------------------------------------
/* BFS tree not graph in case of graphs we pass the adjcent matrix which does it
link for graphs - http://www.sanfoundry.com/java-program-traverse-graph-using-bfs/
link for tree - http://algorithms.tutorialhorizon.com/breadth-first-searchtraversal-in-a-binary-tree/
Level Order Traversal or BFS tree traversal
store the root and den store the left, right den print it checking if left or right present or not.*/
public void BFSTree(Node root){
if(root == null) return null;
//Queue<Node> q = new LinkedList<Node>(); can also declare ref as queue and initialize
as Linklist
Queue<Node> q = new LinkedList <Node>();//cannot initialize(after new) as a queue here
only linkedlist q.add(root);
//Node current = root; while(!q.isEmpty()){
Node n = (Node) q.remove(); //remove from queue and store it in n. System.out.println(n.data()+" ");
if(n.left != null)q.add(n.left);
if(n.right != null)q.add(n.right);
} }
------------------------------------------------------------------
/*Depth first search java tree traversal*/ ------------------------------------------------------------------
/* 2 Largest Increasing Subsequence Interview with Jon. Consider a current and max. if current is less den 0
reset it to zero, if max is less den current set max to current. if current is not less den 0 add elements to current...but dis fails for all -ve numbers in array. so the below approach*/
public int largetOfTwoNumbersSubsequence(int []a){ int current = 0;
int max = 0;
for(int i = 0; i < a.length(); i++){
if(current < 0) current = 0; current += a[i]; if(current > max)
max = current; }
return max; }

 -------------------------------------------------------
/*Kadene's approach...
Link - https://en.wikipedia.org/wiki/Maximum_subarray_problem
take max_ending_here which is max of first element and itself + a[i]....aftr dis tak max of maxx_so_far and amx_ending_here....O(n)*/
public static int largestof2(int[] a){
int max_ending_here=a[0], max_so_far = a[0]; for(int i = 1; i < a.length; i++){
max_ending_here = Math.max(a[i], max_ending_here + a[i]); max_so_far = Math.max(max_so_far, max_ending_here);
}
return max_so_far; }
----------------------------------------------------------------------------------
8tfe
http://collabedit.com/8t8fe
------------------------------------------------------------------ Class Tree{
void inorder(Node root){
if(root == null)return;
stack<Node> s = new stack<Node>(); Node curr = root;
while(!s.Empty() || curr != null){
if(curr != null){ s.add(curr); curr=curr.left;
} else{
curr = s.pop(); System.out.println(curr.data+" "); curr=curr.right;
} }
} ------------------------------------------------------------------
void preorder(Node n){
if(root == null)return;
Stack<Node> s = new Stack<Node>();
 
 Node curr = null; s.push(n); while(!s.isEmpty()){
curr = s.pop(); System.out.println(curr.data); if(curr.right!=null)curr=curr.right; if(curr.left!=null)curr=curr.left;
} }
}
------------------------------------------------------------------
/*check if sum is zero and also root is null i.e EC, interm sum every time to reduce the sum and pass it */
boolean hasPathSum(Node root, int sum){
if(root == null && sum == 0)return true;
if(root == null)return false;
int intermediateSum = sum - root.data;
return hasPathSum(root.left, intermediateSum) ||
hasPathSum(root.right,intermediateSum); }
------------------------------------------------------------------ int balancedTree(Node root){
if(root == null)return -1;
int left = balancedTree(root.left); if(left == -1)return -1;
int right = balancedTree(root.right); if(right == -1)return -1;
int diffHeight = Math.abs(left - right); if(diffHeight>1) return -1;
else return 1+Math.max(left,right);
}
boolean isBalanceTree(){
if(balancedTree(root)==1)return true;
else return false; }

 ------------------------------------------------------------------
/*declare an array of length 256 as boolean and if the character found return false else set true if the character is not found. return true if loop completes.*/
public static isUnique(String str){
boolean[] char_set = new boolean[256]; int len = str.length();
for(int i=0;i<len;i++){
if(char_set[str.charAt(i)])return false;
else char_set[str.charAt(i)] = true; }
return true; }
------------------------------------------------------------------ public static String removeDups(String str){
Hashset<Character> hm = new Hashset<Character>(); String op="";
int len = str.length();
for(int i=0;i<len;i++){
if(!hm.contains(str.charAt(i)){ hm.add(str.charAt(i)); op+=str.charAt(i);
}
return op; }
} ------------------------------------------------------------------ //Using the utility method
import java.util.ArrayList;
import java.util.Collections;
public class Main {
public static String reverseWord(String word,int start,int end){
String rev="";
for(int i=end-1;i>=start;i--){
rev+=word.charAt(i); }
return rev; }
public static void main(String[] args) {
String arrayList;
arrayList = reverseWord("arjun",0,5); System.out.println("Before Reverse Order:" + arrayList);
} }

 ------------------------------------------------------------------ /*Rotate array. for array[1,2,3,4,5,6] with num = 2 1. Divide the array two parts: 1,2,3,4 and 5, 6
2. Rotate first part: 4,3,2,1,5,6
3. Rotate second part: 4,3,2,1,6,5
4. Rotate the whole array: 5,6,1,2,3,4
link - ​http://www.programcreek.com/2015/03/rotate-array-in-java/ equation "(start+end)-i" used to swap first and last
O(1) space and in O(n) time*/
public static void rotateArray(int[] a,int num){
if(num > a.length)return;
rev(a,0,num-1);
rev(a,num,a.length-1);
rev(a,0,a.length-1); //for remaining elements. for(int i:a)System.out.print(i+" ");
}
rev(int[] a, int start, int end){
int mid = (start+end)/2; for(int i = start; i <= mid; i++){
int temp = a[i];
a[i] = a[(start+end)-i]; //important...start from specific location hence this statement. a[(start+end)-i] = temp;
} }
------------------------------------------------------------------
/*Normal method to rotate an array which o(n) in space and o(n) in time. In this example we copy the last 3 elements to the result array and den put first 4 at last of the result in the second for loop.*/
public class Test{
public static void rotate(int[] nums, int k){ int[] result = new int[nums.length]; for(int i=0; i < k; i++){
result[i] = nums[nums.length-k+i]; }
int j=0;
for(int i=k; i<nums.length; i++){
result[i] = nums[j];
j++; }
for(int i=0; i < result.length; i++){ System.out.print(result[i]);
} }
 
 public static void main(String args[]){ int a[] = {1,2,3,4,5,6,7};
int k = 3;
rotate(a,k);
} }
------------------------------------------------------------------ Class Stack{
Node top; Node pop(){
while(top != null){
Object item = top.data; top = top.next;
return item;
}
retun null; }
Node push(){
Node t = new(item); t.next = top;
top = t;
} }
------------------------------------------------------------------
/* Matrix multiplication , in this the row for a remains constant while the column for b matrix remains the same and adding the previous value of c to it */
public int[][] matrixMultiplication(int[][] a, int[][] b){
for(int i=0;i<n;i++){ for(int j=0;j<n;j++){
for(int k=0;k<n;k++){
c[i][j] = c[i][j] + a[ i ][k] * b[k][ j ];
} }
} }
------------------------------------------------------------------
/*valid-parentheses, stack only contains the key value or opening braces. We den take the key and compare with associated value of key with the current character. If it matches den correct.*/
public boolean validParentheses(String s){
HashMap<Character, Character> map = new HashMap<Character,Character>(); map.put('(', ')');
map.put('[', ']');
map.put('{', '}');
Stack<Character> parentheses = new Stack<Character>();

 for(int i=0;i<=s.length();i++){
char curr = s.charAt(i)
if(map.keySet().contains(curr)) //checking the key and if present push the key to the
stack, hence used KeySet() parentheses.push(curr);
else if(map.values().contains(curr)){
if(!parentheses.isEmpty() && map.get(parentheses.peek()) == curr) //check for the
peek and compare it with the value present in the map store by using the get map function parentheses.pop();
else return false //if peek doesn't matches return false. }
}
return parentheses.empty();
}
------------------------------------------------------------------
/* permutation of strings, remember the n-factorial example. swap the elements and do recursion to call the permutation string again do the swap to restore to original position http://www.ericleschinski.com/c/java_permutations_recursion/ - link
public void permutationOfStrings(int[] A,k,n){
if(k==n) {
for(int i=0;i<n;i++) System.out.println(A[i]);
} else {
int t = a[i]; //swap to take the combination of remaining elements a[i] = a[k];
a[k] = t;
permutationofString(A,k+1,n);
int t = a[i]; //swap to restore the original position. a[i] = a[k];
a[k] = t;
} }*/
----------------------------------------------------------------- /*http://www.ericleschinski.com/c/java_permutations_recursion/
Run this code in tutorias point to get. Adding prefix with the first char. Now substring 0 and i location, append substring i+1 to the string...
prefix, str
""
A
AB
ABC (D) ABCD "" ABC D AB C(D)
(A)BCD (B)CD (C)D

 ABD C D was chopped off, because for loop is at index 1 now. looping over 'C' now ABDC "" Add C to prefix. BASE CASE! print: "ABDC".*/
import java.io.*;
public class Main {
private static void permutation(String prefix, String str){ int n = str.length();
if (n == 0)
System.out.println(prefix); else {
for (int i = 0; i < n; i++){
System.out.println("prefix :"+prefix + str.charAt(i)); System.out.println("append :"+str.substring(0, i) + str.substring(i+1)); permutation(prefix + str.charAt(i),
str.substring(0, i) + str.substring(i+1)); //takes first char 'A' and appends 'BCD' den, 'AB' appends 'CD'and so on.
} }
}
public static void main(String[] args) {
permutation("", "ABCD"); }
}
------------------------------------------------------------------
/* Coin problem. Working on one choice and taking combination with other values in arrayList. In recursion remaining acts as numbers and den partial_rec acts as partial*/ public static void main(String args[]){
Integer numbers[] = {1,2,3,45,7,2,}; //declaring an Integer to pass as ArrayList to sum_up() int target = 48;
sum_up(new ArrayList<Integer>(Array.asList(numbers)),target);//ArrayList have dynamic
size whereas array's don't. When we pass integer to arraylist autoboxing converts the integer primitive to integer objects. ArrayList can only store objects while array can store both.
}
static void sum_up(ArrayList<Integer> numbers,int target){ sum_up_recursive(numbers,target,new ArrayList<Integer>());
}
static sum_up_recursive(ArrayList<Integer> numbers,int target,ArrayList<Integer> partial){ int sum = 0;
for(int x: partial) sum += x;
if(sum == target){ //matching with the target...base condition.
System.out.println("Sum" + ArrayList.toString(partial.toArray())+")" +target);
}
if(sum > target) return;

 for(int i = 0; i <numbers.size() ;i++){
ArrayList<Integer> remaining = new ArrayList<Integer>(); int n = number.get(i);
for(int j = i+1; j < numbers.size(); j++)
remaining.add(numbers.get(j)); //all the remaining element into it except one. ArrayList<Integer> partial_rec = new ArrayList<Integer>(partial);//dis builds an arraylist
partial_rec with partial.
partial_rec.add(n);//adding the first element from numbers sum_up_recursive(remaining,target,partial_rec);
}
} ------------------------------------------------------------------ /* above same problem in python */
def sum_set (numbers, target, partial=[]):
s = sum(partial) if s == target
print "s%s = %s" %s (partial,target) if s > target
return
for i in range(len(numbers)):
n = numbers[i]
remaining = numbers[i+1:] sum_set(remaining, target, partial + [n])
if __name__ == "__main__": subset_sum([3,9,8,4,5,7,10],15)
------------------------------------------------------------------ #sample python with main class
class Example(Object):
def add()
print "Hi how are you" #if not we return .
if __name__ == "__main__": Example().add()
------------------------------------------------------------------
/* remove duplicates from a large file, 1) first answer that u can use hashmap but con of it is that it gives javarunoutofmemory for larger set like 15million records.
2)The key is that your data will not fit into memory. You can use external merge sort for this:Partition your file into multiple smaller chunks that fit into memory. Sort each chunk, eliminate the duplicates (now neighboring elements).Merge the chunks and again eliminate the duplicates when merging. Since you will have an n-nway merge here you can keep the next k elements from each chunk in memory, once the items for a chunk are depleted (they have been merged already) grab more from disk.*/
public void removeDuplicateFromFile(){

 }
----------------------------------------------------------------------------------
b9exc
http://collabedit.com/b9exc
------------------------------------------------------------------ ------------------------------------------------------------------
Two pointers concept, hash contains or not used in many problems to find solutions. ------------------------------------------------------------------
public class demo{
Hashtable sample = new Hashtable(); sample.put("arjun","mantri"); sample.get("arjun"); sample.containsKey("key");
}
------------------------------------------------------------------
/* Dijktras - greedy approach.
Shortest path */
private final List<Vertex> nodes;
private final List<Edge> edges;
/*pseudo code*/
/*In the method below we declare different list for distance, unsettled, settled nodes, predecessor wherein we store the parent node. Loop thru the unsettled, add to settle, remove from unsettle and findtheNeighboures*/
public void dijktras(Vertex source){
Set unsettledNodes = new HashSet<Vertex>();
Set settledNodes = new HashSet<Vertex>(); HashMap distance = new HashMap<Vertex,Integer>(); HashMap predecessor = new HashMap<Vertex>(); distance.put(source,0);
while(unsettledNodes.size() > 0){
Vertex node = getMinimum(unsettledNodes); settledNodes.add(node); unsettledNodes.remove(node); findMinimalDistance(node);

 } }
/*In the method below find the neighbour nodes, get the distance directly or via some node store that into distance list, add that target node to the predesscor which is the parent list and finally adding that to the unsettled nodes list*/
public void findMinimalDistance(Vertex node){
List <Vertex> adjacentNodes = getNeighbors(node); for(Vertex target : adjacentNodes){
if(getShortDistance(target) > (getShortDistance(node)+ getDistance(node,target))){ distance.put(target, getShortDistance(node)+ getDistance(node,target)); predecessor.put(target);
unsettledNodes.add(target); //adding the remaining from the for loop to the
unSettledNodes. }
} }
/*checks for the source and destination of the edge. Check if the destination is present in the settled or not and then add to the neighbors list. return this list*/
public List<Vertex> getNeighbors(Vertex node){
List<Vertex> neighbors = ArrayList<Vertex>(); for(Edge edge: edges){
if(edge.getSource().equal(node) && !isSettled(edge.getDestination())){ neighbors.add(edge.getDestination());
} }
return neighbors; }
/*Get the edge source and destination, match with values pased. Return the weight. Since we are checking the settled nodes in the getNeighbors so no need to check it here*/ public double getDistance(Vertex node, Vertex target){
for(Edge edge: edges){
if(edge.getSource().equal(node) && edge.getDestination().equals(target)){
return edge.getWeight(); //return the weight of the edge }
} }
/* get minimum node vertex by comparing the minimum & de vertex */ public Vertex getMinimum(set<Vertex> vertexes){
Vertex minimum = null; for(Vertex vertex : vertexes){
if(minimum == null){ minimum = vertex;
}
else if(getShortDistance(minimum) > getShortDistance(vertex)){
minimum = vertex; }

 }
return minimum; }
/* get the shortest distance and return the corresponding int value*/ public double getShortDistance(Vertex node){
int d = distance.get(node); if(d == null){
return Integer.MAX_VALUE; }
else return d; }
/*returns if the vertex is present in the settled node list or not*/ Private boolean isSettled(Vertex vertex){
return settledNodes.contains(vertex); }
public List<Vertex> getPath(Vertex target){
} ------------------------------------------------------------------ public void uniqueString(String word){
boolean[] char_set = new boolean[256]; for(int i=0;i<word.length();i++){
int val = word.charAt(i); if(char_set[val]) return false; char_set[val] = true;
if() return true;
}
} ------------------------------------------------------------------ public void uniqueString(String word){
HashMap check = new HashMap<> }
------------------------------------------------------------------ public String checkDuplicate(String str){
if(str==null)return null;
HashMap<Character> checkDup = new HashMap<Character>(); String remove = "";
for(int i =0; i< str.length(); i++){
if(!checkDup.contains(str.charAt(i))){ checkDup.add(str.charAt(i)); remove+=str.charAt(i);
} }

 return remove; }
------------------------------------------------------------------
/*isAnagram or not. add to the hashmap if not present with +1 as the count, if already present than do "++" for the same count (for string a). Now for string b check if the char in present in the map, if count is 1 den remove or else do "--"...if empty its anagram*/
public boolean isAnagram(String a, String b){
boolean check = false;
if(a.length() != b.length()) return check;
HashMap<Character,Interger> m = new HashMap<Character,Integer>(); Char[] p = a.toLowerCase().toCharArray();
Char[] q = b.toLowerCase().toCharArray();
for(int i = 0; i < p.length(); i++){ if(m.contains(p[i]){
int temp = m.get(p[i]);
m.add(p[i],temp++); }
else{ m.add(p[i],1);
} }
for(int i = 0; i < q.length(); i++){ if(m.contains(q[i])){
int temp = m.get(q[i]); if(temp == 1){
m.remove(q[i]); }
else{ m.add(q[i],temp--);
} }
else return flag; //if its not present in the map den return false.
} if(m.isEmpty()){
System.out.println("Anagram found");
return true; }
} ------------------------------------------------------------------ class Node{
Node next = null; int data; Node(int data){

 Node.data = data; }
void appendTail(int data)
Node end = new Node(data); Node n = this;
while(n.next != null){
n = n.next; }
n.next = end; }
public Node deleteNode(Node head, int data){ if(n.data == data){
return head.next; }
while(n.next != null){ if(n.data == data){
n.next = n.next.next;
return head; }
n = n.next; }
} }
------------------------------------------------------------------
/* use two hashtable to check if the element is present or not if not - add and make value as true*/
public void removeDup(Node head){
HashTable m = new HashTable(); Node n = head;
Node previous = null
while(n != null){
if(!m.contains(n.data)){ m.put(n.data,true);
previous = n; //set previous as n
} else{
previous.next = n.next.next; //if duplicate den set next to next for current. }
n = n.next; }
} ------------------------------------------------------------------ public void removeDupTwoptr(Node head){
Node curr = head; Node runner = curr;

 while(curr != null){
runner = curr; //setting again runner to the current node. while(runner.next != null){
if(curr.data == runner.data){//checks for the duplicates for current with next to next and if yes places it
runner.next = runner.next.next; }
else {
runner = runner.next; //moving the runner to the next node.
} }
curr = curr.next; //moving the curr to the next node for outer while loop. }
} ------------------------------------------------------------------ /* Find Nth element from LinkList */
public Node nThNode(Node head, int n){
if(head == null || n < 1) return null; Node p1 = head;
Node p2 = head;
for(int i = 0; i < n-1; i++){
if(p2 == null){ System.out.println("Not found");
}
p2 = p2.next; }
while(p2 != null){ p1 = p1.next; p2 = p2.next;
}
return p1; }
------------------------------------------------------------------ /*Design an OO parking lot*/.l ------------------------------------------------------------------ /* isbst */
public boolean isBinarySearchTree(TreeNode p, int min, int max){ if(p == null) return true;
if(p.val < min || p.val > max) //not equal to max since the return false;
return isBinarySearchTree(p.left,min,p.val) && isBinarySearchTree(p.right,p.val,max); }
------------------------------------------------------------------
/* Find the minimum value in the binary search tree */

 public int minBST(Node root){ if(root.left == null) return root.val;
return minBST(root.left); }
------------------------------------------------------------------ /* need to look into this */
public Node deleteNode(Node n){
if(n == null || n.next == null) return ;
n.data = n.next.data; n.next = n.next.next; return true;
}
/* in the above solution the last node is not delted hence the below method */
void deleteNode(Node node, Node n) {
        // When node to be deleted is head node
        if (node == n) { //check for the head condition.
            if (node.next == null) {
                System.out.println("There is only one node. The list "
                                 + "can't be made empty ");
return; }
            /* Copy the data of next node to head */
            node.data = node.next.data;
            // store address of next node
            n = node.next;
            // Remove the link of next node
            node.next = node.next.next;
            // free memory
            System.gc();
return; }
        // When not first node, follow the normal deletion process
        // find the previous node
        Node prev = node;
        while (prev.next != null && prev.next != n) {
            prev = prev.next;
        }
        // Check if node really exists in Linked List
        if (prev.next == null) {
            System.out.println("Given node is not present in Linked List");

 return; }
        // Remove node from Linked List
        prev.next = prev.next.next;
        // Free memory
        System.gc();
return; }
------------------------------------------------------------------ public boolean addLinkList(Node head1, Node head2){
if(str1 != str2) return false;
int count = 0;
for(int i = 0; i < str1.length(); i++){
if(str1.charAt(i) != str2.charAt(2)) count++;
if(count > 1) return false; }
return true; }
------------------------------------------------------------------ public void sumList(Node head){
Node head1 = head; while(head1.next != null){
head1 = head1.next; }
while(head.next != null){
head.data = head.data + head1.data; if(head.data > 9){
}
head = head.next; }
}
------------------------------------------------------------------ /*BFS tree traversal using python*/
from collections import deque
class Node:
def __init__(self,info):
self.info = info self.left = None

 self.right = None self.level = None
def __str__(self): return str(self.info)
def BFT(root):
self.root.level = 0
queue = [self.root]
out = []
current_level = self.root.level
while len(queue)>0:
current_node = queue.popleft()
if(current_node.level > current_level): output.append("\n")
current_level += 1
output.append(str(current_node))
if current_node.left != None:
current_node.left.level = current_level + 1 queue.append(current_node.left) //appending to the queue the left node
if current_node.right != None: current_node.right.level = current_level + 1 queue.append(current_node.right)
return ''.join(output)
root = Node(9) root.left = Node(2) root.right = Node(4)
root.left.left = Node(1) root.left.right = Node(3)
root.right.left = Node(5) root.right.right = Node(7)

 print BFT(root)
------------------------------------------------------------------
/*Implementation of hashmap... Implement Hash Tables Chaining with List Heads
link : -​http://www.sanfoundry.com/java-program-implement-hash-tables-chaining-list-heads/ * Java Program to Implement Hash Tables Chaining with List Heads
get key is done with getting the hash value of table, iterating thru the link list, if entry is null return null else return the value for that key.
insertThekey method does the same as said above, only if it finds the same key with the equals den it inserts the and if on the same location after hashing it creates entry.next to store on the next location.
myhash function does the hashing
*/
/* Function to get value of a key */ public int getKey(String key){
int hash = (myhash(key) % Table_Size); if(table[hash] == null){
return -1;//return NotFoundException }
else{//start of else
LinkedhashEntry entry = table[hash];//linkedhash entry is the class name. while(entry != null && !entry.key.equals(key))
{
entry = entry.next; }
if(entry == null) return -1;
else
return entry.value;
}//end of else }
/* Function to insert a key value pair */ public void insert(String key, int value){
int hash = (myhash (key) % Table_Size); if(table[hash] == null)
table[hash] == new LinkedhashEntry(key, value); else{
LinkedhashEntry entry = table[hash];
while(entry != null && !entry.key.equals(key)){//checks if the the same key is showing up again or not
entry = entry.next; }
if(entry.key.equals(key))
entry.value = value; //key are equal so set the value.
 
 else
entry.next = new LinkedhashEntry(key, value); //make an entry when collision occurs
}
size++; }
/* Function myhash which gives a hash value for a given string */ private int myhash(String x )
{
int hashVal = x.hashCode( ); hashVal %= TABLE_SIZE;
if (hashVal < 0)
hashVal += TABLE_SIZE; return hashVal;
}
------------------------------------------------------------------ /*implementation of hashmap other approach */
​​public​​ ​​void​​ put(K newKey, V data)​​{ ​if​​(newKey==​null​​)
​return​​; ​//does not allow to store null.
​//calculate hash of key.
​int​​ hash=hash(newKey);
​//create new entry.
Entry<K,V> newEntry = ​new​​ Entry<K,V>(newKey, data, ​null​​);
​//if table location does not contain any entry, store entry there. ​if​​(​table​[hash] == ​null​​){
​table​[hash] = newEntry; }​else​​{
Entry<K,V> previous = ​null​​; Entry<K,V> current = ​table​[hash];
​while​​(current != ​null​​){ ​//we have reached last entry of bucket. ​if​​(current.​key​.equals(newKey)){
​if​​(previous==​null​​){ ​//node has to be insert on first of bucket. newEntry.​next​=current.​next​;
​table​[hash]=newEntry;
​return​​;
} ​else​​{
newEntry.​next​=current.n​ ext​; previous.​next​=newEntry; ​return​​;
}

          }
         previous=current;
current = current.​next​; }
previous.​next​ = newEntry; }
}
​/**
* Method returns value corresponding to key. * ​@param​​ key
*/
​public​​ V get(K key)​​{
​int​​ hash = hash(key); ​if​​(​table​[hash] == ​null​​){
​return​​ ​null​​; }​else​​{
Entry<K,V> temp = ​table​[hash]; ​while​​(temp!= ​null​​){
​if​​(temp.​key​.equals(key)) ​return​​ temp.​value​;
temp = temp.​next​; ​//return value corresponding to key. }
​return​​ ​null​​; ​//returns null if key is not found. }
}
------------------------------------------------------------------
/*Find the contiguous subarray within an array (containing at least one number) which has the largest sum.
For example, given the array [−2,1,−3,4,−1,2,1,−5,4], the contiguous subarray [4,−1,2,1] has the largest sum = 6.
link - http://www.programcreek.com/2013/02/leetcode-maximum-subarray-java/
In this we take sum of previous and current, current and take maximum out of this 2 and assign to maximum from it. Now that max value is store into sum array first and den into max variable.*/
 ​public​​ ​int​​ maxSubArray​(​int[​​ ]​ A)​ ​ ​{
 ​int​​ newsum​=​A​[​0​]​;
 ​int​​ max​=​A​[​0​]​;
 ​for​​(​int​​ i​=​1​;​i​<​A.​length​;​i​++​){
 newsum​=​Math​.​max​(​newsum​+​A​[​i]​ ​,A​[​i​])​;
 max​=​ ​Math​.​max​(​max, newsum​);​
 ​}

  ​return​​ max​;
 ​}
------------------------------------------------------------------
/* Longest Increasing Subsequence .
link - http://blog.welkinlan.com/2015/11/05/longest-increasing-subsequence-leetcode-java/
In this compare if the previous is less den the next one i.e nums[i] > nums[j] and take all the elements that are less den j, now get the maximum of the dp[i] and dp[j] + 1 so whichever gives the maximum set to dp and den again in the outer for loop get the max form the dp and max and set it to max.*/
public class LongestIncreasingSubsequence{
public int length(int[] nums){ if(nums.length == 0 || nums == null)
return 0;
int[] dp = new int[nums.length];
int max = 1;
for(int i = 0; i < nums.length; i++){
dp[i] = 1;//setting to 1 which is added everytime...dis is 1 bcoz if nothing is found the
largest will be only one number hence 1. for(int j = 0; j < i; j++){
if(nums[i] > nums[j]) //if it is greater den only add the to dp array.
dp[i] = Math.max(dp[i], dp[j] + 1); }
max = Math.max(dp[i], max); }
return max; //longest length of the subsequence. }
}
Linkedin Question Prep.
//isIsomorphic..We need to define a method which accepts a map & a value, and returns the value's key in the map.
//For example,"egg" and "add" are isomorphic, "foo" and "bar" are not. Check in the hashmap if the value is currently present or not if not return false and also if not matches return false.
public boolean isIsomorphic(String s, String t) { if(s==null || t==null)
return false;
if(s.length() != t.length())
return false;
if(s.length()==0 && t.length()==0) //if both the length are zero return true
return true;
HashMap<Character, Character> map = new HashMap<Character,Character>(); for(int i=0; i<s.length(); i++){

 char c1 = s.charAt(i);
char c2 = t.charAt(i);
Character c = getKey(map, c2); //get the key of c2 to do the follwing conditions. get key
for dat particular value
if(c != null && c!=c1){ //check if matches with c1(character at ) if not false
return false;
}else if(map.containsKey(c1)){//if c1 is key and check if c2 is value of the key c1 if not
return false
if(c2 != map.get(c1))
return false;
}else{
map.put(c1,c2); //else add to the map. This will take place at very first time adding to
the map (e,a).
}
}
return true;
}
// a method for getting key of a target value
public Character getKey(HashMap<Character,Character> map, Character target){
for (Map.Entry<Character,Character> entry : map.entrySet()) { // entryset() method call returns a set view of the mappings contained in this map.
if (entry.getValue().equals(target)) {
return entry.getKey();
}
}
return null;
}
//
count the occurence in sorted array: since the array is sorted we can get the first and last index subract them to get the count of the number.
/*Method 1 (Linear Search)
Linearly search for x, count the occurrences of x and return the count.
Time Complexity: O(n)
Method 2 (Use Binary Search)
1) Use Binary search to get index of the first occurrence of x in arr[]. Let the index of the first occurrence be i.
2) Use Binary search to get index of the last occurrence of x in arr[]. Let the index of the last occurrence be j.
3) Return (j – i + 1); */
package Arrays;
public class OccurrencesInArray {
public int findOccurrences(int [] arrA, int x){
int count = 0;
int startPoint = findFirstOccurrence(arrA,x,0,arrA.length1)
;//findingfirst occurence
if(startPoint<0){

 return 1;
}
int endPoint = findLastOccurrence(arrA, x, 0, arrA.length1)
;//findinglast occurence
count = endPoint-startPoint+
1;
return count;
}
public int findFirstOccurrence(int [] arrA, int x,int start, int end ){
if(end>=start){
int mid = (start+end)/2;
if((mid==0||(arrA[mid1]<
x)) && arrA[mid]==x){ //check if the middle elem is eq to x
den return mid and also checkng elem before is less den x den return mid which is index for frst occurnce.
return mid;
}else if(arrA[mid]<x){
return findFirstOccurrence(arrA, x, mid+1, end);//increase mid value bcoz de frst
occurnce iz on the right
}else{
return findFirstOccurrence(arrA, x, start, mid1)
;//every time reducing the size of
mid and passing it again.
}
}else return 1;//
if not found
}
public int findLastOccurrence(int [] arrA, int x,int start, int end ){
if(end>=start){
int mid = (start+end)/2;
if((mid==arrA.length1||
arrA[mid+1]>x) &&(arrA[mid]==x)){//check if the middle elem
is eq to x den return mid and also checkng elem before is greater den x den return mid which is index for frst occurnce.
return mid;
}else if(arrA[mid]>x){
return findLastOccurrence(arrA, x, start, mid1)
;//reduce the mid size bcoz de last
occurnce is on the left from last.
}else{
return findLastOccurrence(arrA, x, mid+1, end); //every time reducing the size of
mid and passing it again.
}
}else return 1;
//if not found return 1
}

 public static void main(String args[]){
int [] arrA = {1,2,2,2,2,2,2,2,3,4,5,5,6};
int x = 2;
OccurrencesInArray i = new OccurrencesInArray();
int r = i.findOccurrences(arrA, x);
System.out.println("No of Occurrences of number " + x + " is : " + r); }
}
/*
We do a for loop over all the string's characters and save the current char in the charAt variable
We check if our HashMap already has a charAt key inside it
If it's true we will just get the current value and add one.. this means the string has already been found to have this char.
If it's false (we never found a char like this in the string), we add 1 because we found a new char
Stop! Our HashMap will contains all chars (keys) found and how many times it's repeated (values)!*/
String str = "Hello World";
int len = str.length();
Map<Character, Integer> numChars = new HashMap<Character, Integer>(Math.min(len, 26));
for (int i = 0; i < len; ++i)
{
char charAt = str.charAt(i);
if (!numChars.containsKey(charAt)) //if it does not contains add to the hashmap
{
numChars.put(charAt, 1);
}
else
{
numChars.put(charAt, numChars.get(charAt) + 1); //already present increment it by one
}
}
System.out.println(numChars)
//
approach 2 for the above given problem.
String str = "Hello World";
int[] counts = new int[(int) Character.MAX_VALUE];
// If you are certain you will only have ASCII characters, I would use `new int[256]` instead for (int i = 0; i < str.length(); i++) {
char charAt = str.charAt(i);
counts[(int) charAt]++;
}
System.out.println(Arrays.toString(counts));

 /*
worddistance. In a given list of tokenized string find the minimum distance betwn dem. Compare if the word in the list is equal to the target list word if yes set the index to i value. Now take the value of shortdistance as the difference between the two indexa and indexb. Take the mininmum of the shortdistance as well the absolute of the difference between indexa and indexb. //O(n) complexity; O(1) space;
("the", "quick", "brown", "fox", "quick")*/
public class wordDistance{
List <String> lst;
public wordDistance(List<String> lst){
this.lst = lst;
}
public void minWordDistance(String a, String b){
int indexa = 1;
int indexb = 1;
int mindistance = 1;
for(int i = 0; i < lst.length(); i++){
String currWord = lst.get(i);
if(currWord.equals(a)) //match the "a" word and if yes set indexa to i
indexa = i;
else if(currWord.equals(b)) //match the "b" word and if yes set indexa to i
indexb = i;
else
continue;
if(!indexa = 1
&& !indexb = 1){
//initialize the first shortestDistance, at very first.
if(mindistance < 0)
shortestDistance = Math.abs(indexa - indexb);
else
shortDistance = Math.min(shortestDistance, Math.abs(indexa - indexb))
;
}
} //end of for loop.
return mindistance;
}
public static void main(String...arg){
WordDistanceFinder finder = new WordDistanceFinder(Arrays.asList("the", "quick", "brown", "fox", "quick"));
System.out.println(finder.distance("fox","the"));
System.out.println(finder.distance("quick", "fox"));
}
}

 /*
postfix, Reverse polish notation...push the number to stack and if operator den pop, calculate and push again back to. Remeber to convert to integer from string and convert integer to string while pushing to stack */
public class Test {
public static void main(String[] args) throws IOException {
String[] tokens = new String[] { "2", "1", "+", "3", "*" }; System.out.println(evalRPN(tokens));
}
public static int evalRPN(String[] tokens) {
int returnValue = 0;
String operators = "+*/"
;
Stack<String> stack = new Stack<String>();
for (String t : tokens) {
if (!operators.contains(t)) { //push to stack if it is a number
stack.push(t);
} else {//pop numbers from stack if it is an operator
int a = Integer.valueOf(stack.pop());
int b = Integer.valueOf(stack.pop());
switch (t) {
case "+":
stack.push(String.valueOf(b + a));
break;
case " - ":
stack.push(String.valueOf(b - a))
;
break;
case "*":
stack.push(String.valueOf(b * a));
break;
case "/":
stack.push(String.valueOf(b / a));
break;
}
}
}
returnValue = Integer.valueOf(stack.pop());
return returnValue;
}
}
/*
start = "hit"
end = "cog"
dict = ["hot","dot","dog","lot","log"]
One shortest transformation is "hit" >

 "hot" >
"dot" >
"dog" >
"cog", the program should
return its length 5.
declare a constructor, queue to add the word, get the top word convert it to chararray if match found return.
Replace the first character with new one and continue it checking in dictionary if present or not, if present add to queue and remove from dictionary. Increase the steps to +1 as well.*/ class WordNode{
String word;
int numSteps;
public WordNode(String word, int numSteps){
this.word = word;
this.numSteps = numSteps;
}
}
public class Solution {
public int ladderLength(String beginWord, String endWord, Set<String> wordDict) { LinkedList<WordNode> queue = new LinkedList<WordNode>();//queue using linkedlist queue.add(new WordNode(beginWord, 1)); //queue of objects WordNode. wordDict.add(endWord);//adding the last word in dicitionary
while(!queue.isEmpty()){
WordNode top = queue.remove();
String word = top.word; //get the top word
if(word.equals(endWord)){ //break condition if the word matches.
return top.numSteps;
}
char[] arr = word.toCharArray();//convertng to charArray.
for(int i=0; i<arr.length; i++){
for(char c='a'; c<='z'; c++){ //this replaces the first character with the new
characterin this example "hit" to "ait" and so on....
char temp = arr[i];
if(arr[i]!=c){//to check if we are nt appendng same char.
arr[i]=c;
}
String newWord = new String(arr);
if(wordDict.contains(newWord)){
queue.add(new WordNode(newWord, top.numSteps+1)); //add de new word
to queue.
wordDict.remove(newWord);//remove word frm dictionary.
}
arr[i]=temp;//restore the original char in dis case at first "h" char fr de frst tym
and again repeat the for loop for different char.
}
}

 }
return 0;
}
}
/*
second approach and correct approach to get the min distance*/ package sample;
import java.util.*;
public class WordLadder2 {
String word;
int numSteps; WordLadder2 pre;
public WordLadder2(String word, int numSteps, WordLadder2 pre){ this.word = word;
this.numSteps = numSteps;
this.pre = pre;
}
public List<List<String>> findLadders(String start, String end, Set<String> dict) { List<List<String>> result = new ArrayList<List<String>>();//List of list string
@frst
LinkedList<WordLadder2> queue = new LinkedList<WordLadder2>(); queue.add(new WordLadder2(start, 1, null));//setting the numSteps value to 1
dict.add(end); int minStep = 0;
HashSet<String> visited = new HashSet<String>(); HashSet<String> unvisited = new HashSet<String>(); unvisited.addAll(dict);//adding all de words @frst
int preNumSteps = 0;//previous steps set to 0
while(!queue.isEmpty()){
WordLadder2 top = queue.remove();
String word = top.word; //getting the top word
int currNumSteps = top.numSteps;//getting the current numsteps
if(word.equals(end)){//if word matches the end word. if(minStep == 0){
minStep = top.numSteps;//set de val of minStep = 1 @frst

 }
if(top.numSteps == minStep && minStep != 0){ //nothing
ArrayList<String> t = new ArrayList<String>(); t.add(top.word);
while(top.pre !=null){
t.add(0, top.pre.word);//adding previous word to the ‘0’ location
top = top.pre;//go to next one }
result.add(t);
continue; }
}//end of word.equals(end) if loop
if(preNumSteps < currNumSteps){ unvisited.removeAll(visited);//rmve ol visted since
}
preNumSteps = currNumSteps;//if nt set pre to curr
//In this we replace the each char with each char in the word and den after dat check
if it is present in the unvisited word list if yes den add to the queue and increase the steps by 1, and add dat word to the visited hashset(). Now den restore to the original word and start over again.
char[] arr = word.toCharArray(); for(int i=0; i<arr.length; i++){
tym
}
for(char c='a'; c<='z'; c++){//this replaces the first character with the new //character in this example "hit" to "ait" and so on....
char temp = arr[i];
if(arr[i]!=c){//to check if we are nt appendng same char.
arr[i]=c; }
String newWord = new String(arr); if(unvisited.contains(newWord)){
queue.add(new WordLadder2(newWord, top.numSteps+1, top));
visited.add(newWord);//add to visited }
arr[i]=temp;//restore the original char in dis case at first "h" char fr de frst
//and again repeat the for loop for different char. }//end of for loop.

 }
}
return result; }
/*
Place the flower on the flowerbed. Check for the left and right of numberToPlace if there
are zero's around that number den u can add it. It has three if conditions wherein first checks for prev, second for next and last one if correctSpot matches with the numbertobeplaced */ package sample;
import java.util.List;
public class FlowerBed {
public boolean canPlaceFlowers(List<Boolean> flowerbed, int numberToPlace) {
// Implementation here
// list size 0
int size = flowerbed.size();
if (size == 0 || size < numberToPlace) {
return false; }
if (numberToPlace == 0) {
return true; }
// find a 0, look at element on left and right, increment
// if the 0 is at the beginning or end, only need neighbor to be 0 int correctSpot = 0;
for (int i =0; i < size; i++) {
Boolean prev = false; Boolean next = false;
if (flowerbed.get(i) == false) {
if (i > 0) {

 //
//
// } }
prev = flowerbed.get(i-1);//check the previous one if (prev != false) //plant in placed in this location
{
continue; }
}
if (i < size-1) {
next = flowerbed.get(i+1); //check the next one if (next != false) //plant in placed in this location {
continue; }
}
//flowerbed.add(i, true);
correctSpot++; //hence the correct spot spotted. if (correctSpot == numberToPlace)
{
flowerbed.add(i, true);
return true; }
} //end of if condition flowerbed.get(i) == false
}//end of for loop return false;
}
public static void main(String args[]){
List<Boolean> a = new List<Boolean>();
/*
Number of triangle that can be formed using given array of numbers. crude way is to do brute force using three for loop and den putting the cndition which results in complxty O(n3). First sort the array and then compare if A1<A2+A3 if dis is true it holds true for every other condition that is A2<A1+A3 and A3<A1+A3. If we apply the brute force. Hence instead of O(n3) it takes O(n2logn)
Link https://
www.quora.com/Whatistheefficientalgorithmtofindthenumberoftrianglespossib leinagivenarrayorvector
*/
public int[] getTriangleSides(int[] segments)
{
int []output={};

 if(segments.length < 3)
return throw new IllegalArgumentException (“Number of variables required are less to form tri”)
Arrays.sort(segments);
//the tripplet will come in order if exists after sorting
int i=0,j=1,p=0; //to start of with different elements.
for(int k=2;k<segments.length;i++,j++,k++)
{
//assume segments[i],segments[j],segments[k] are three sides of a triangle if(segments[i]+segments[j]>segments[k])
{
output[p++]=segments[i];
output[p++]=segments[j]; output[p++]=segments[k]; break; //if asked only for 1.
} }//end
return output; }
/*
another brute force approach...Triangle triplet o(n3) complexity.*/
/*
Given a array of positive integers, find all possible triangle triplets that can be formed from this array.
eg: 9 8 10 7
ans: 9 8 10, 9 8 7, 9 10 7, 7 8 10
Note : array not sorted...this has the complexity of O(n3).
*/
public class TriangleTriplet {
public void triangleTriplet(int a[])
{
int n=a.length;
for(int i=0;i<n;i++)
{
for(int j=0;j<n;j++)
{
for(int k=0;j<n;j++)
{
if(i!=j && j!=k && i!=k) //make sure that the 3 of them do not match which will
cause to take the same variable again and again.
if(a[i]+a[j]>a[k] && a[j]+a[k]>a[i] && a[i]+a[k]>a[j])
{
System.out.println(a[i]+" "+a[j]+" "+a[k]);
}
}
}

 }
}
public static void main(String[] args) {
// TODO Autogenerated
method stub
int a[]={9,8,7,10};
new TriangleTriplet().triangleTriplet(a);
}
}
/*
Build a tree using the given values
Child Parent IsLeft
15 20 true
19 80 true
17 20 false
16 80 false
80 50 false
50 null false
20 50 true
1st approach. In this v first find the root. after which v compare the element in queue parent is same with the "Data" list element if yes den new child is formed and den checkng isLeft for it, if true put to the left of the parent else put to the rigth of the parent. Now also make sure if the child are added to the root are not more den 2. Now add this to the queue and repeat the process. return the root of the tree.*/
public static Node buildTree(List<Relation> data){
if(data==null) return new Node();
Node root=new Node();
int children=0;
for(int i=0;i<data.size();i++){
Relation x=data.get(i);
if(x.parent==null){ //finding root if the value of parent is null
root=new Node(x.child,null,null);
break;
}
}
if(root==null) return root;
Queue<Node> q=new LinkedList<Node>();
q.add(root);
while(!q.isEmpty()){
Node x=q.poll();//poll remove the head from queue and stored into x.
for(int i=0;i<data.size();i++){
Relation y=data.get(i);
if(y.parent==x.id){ //comparing if parent are the same
Node n=new Node(y.child,null,null);//create a new child
if(y.isLeft) //put to the left or right
x.left=n;

 else x.right=n;
q.add(n);
children++;
if(children==2){ //children should not be more den 2 children=0;
break;
}
}//end of parent if statement
}
}//while loop
return root;//returning the root.
}
/*
2nd.......Another way to approach this problem for a better running time could be by using a HashMap. We can hash the list with key as the parent and value as a list of its children. And then iteratively generating the tree. This solution would be O(n) time complexity and O(n) space complexity.*/
public static Node buildTree(List<Relation> data){
if(data==null) return new Node();
Node root=new Node();
HashMap<Integer,ArrayList<Relation>> tree = new HashMap<Integer,ArrayList<Relation>>();
ArrayList<Relation> value = new ArrayList<Relation>();//declared here to store the child
info and den pass it to hashmap as value with key as the parent.
for(Relation d:data){
if(d.parent==null)
root=new Node(d.child,null,null);
else{
if(tree.containsKey(d.parent)){
ArrayList<Relation> value=tree.get(d.parent);//store the parent's values i.e
relations into the value arraylist
value.add(d);
} else {
ArrayList<Relation> value = new ArrayList<Relation>();//if entry is not present
den it is put into the arraylist and den added to hashmap providing key and value as parent and values.
value.add(d);
tree.put(d.parent,value);
}
}
}
if(root==null) return root;
Queue<Node> q = new LinkedList<Node>();
q.add(root);
while(!q.isEmpty()){
Node x = q.poll();

 if(tree.containsKey(x.id)){//to check if the parent is present or not in hashmap. ArrayList<Relation> value=tree.get(x.id);
for(Relation v:value){ //in this we have already mapped parent so no need to compare if parent or not as in the previous approach.
Node child = new Node(v.child,null,null); q.add(child);
if(v.isLeft)
x.left=child;
else x.right=child; }
}
}
return root; }
/*
Two sum problem
Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution.
Example:
Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9, Return true for 9
Link
https://github.com/fcarriedo/algorithms/blob/master/exercises/twosumtest/TwoSumTest.java
/**
* Implementation with linear O(n) complexity on 'store'
* and O(1) complexity on 'test'.
*
* Focuses logic into the 'store' algorithm, not in the 'test'
*/
Add element to the internalStore set and den store suming each of dem into the sum “hashset” , now check if it is present in the ‘sum’ hashset.
*/
Class twoSumLinear{
private final Set<Integer> internalStore = new Set<Integer>();
private final HashSet<Integer> sum = new HashSet<Integer>();
void store(int input){
// We calculate all the sums upon storage
if(internalStore.contains(input)) return;​// We already have it
for(int value: internalStore){
 
 sum.add(value+input);
}
// Add it to the store internalStore.add(input); }
boolean test(int test){ return (sum.conatins(test)); }
}
/*
Regular expression to check if the string contains number or not
It is a regular expression which means:
^ beginning of the string
()?
the hyphen appear one or no times
[09]+
there are one or more digits sequentially
(\\.)? the period appears one or no times (\ is the escape character for the .)
[09]+
there are one or more digits sequentially
$ end of the string */
//"?" is used to match for one or more occurence while "*" is used for 0 or more occurence, "$" Matches end of line.
// First approach: with different test cases.
//String regex = "^(\\+|)?[09]*(\\.)?[09]*$";
String str = "123.2"//it can be either of the values from below given.
boolean a = str.matches("^(\\+|)?[09]*(\\.)?[09]*$");
System.out.println(a);
Pattern p = Pattern.compile(regex);
assertTrue (p.matcher("123.123").matches());
assertTrue (p.matcher("123.123").matches());
assertTrue (p.matcher("+123.123").matches());
assertFalse (p.matcher("+123s123").matches());
assertTrue (p.matcher(".123").matches());
assertTrue (p.matcher("0.123").matches());
assertTrue (p.matcher("0.").matches());
assertTrue (p.matcher(".0").matches());
assertTrue (p.matcher(".10").matches());
assertTrue (p.matcher(".").matches());
/*
recurvisly call the number if + pass n1

 and if negative pass n+1.
if n == 0 is the base condition. for 2^5 and 2^5...
now in frst case n-1
so 5-1, 4-1, 3-1...
and
second case 5+1, 4+1....*/
public class RaiseDouble {
public static double computePower(double x, double n){ //base case
if(n==0){
return 1;
}else if(n>0){ //recursive condition for postive power return x*computePower(x, n1)
;
}else if(n<0){ //recursive condition for negative power return (1/x)*computePower(x, n+1); //1/x
}else{
return 1;
}
}
/**
* <p>Compute power</p> *
* p(x,n) = 1 if(x=0)
* = x*p(x,n1)
if(n>0)
* = (1/x)*p(x,n+1) if(n<0)
* @param x
* @param n
* @return
*/
public static void main(String[] args) {
// TODO Autogenerated
method stub System.out.println(computePower(2,5)); System.out.println(computePower(2,5)); System.out.println(computePower(2,5)); System.out.println(computePower(2,-5)); }
}
/*
Middle element of stack using O(1)
We use the concept of stack using linklist but with only change that we check the “size” as well in which we */
public class MiddleElementStackO1 {

 public void push(T item) {
final Node < T > node = new Node < T > (null, item, top); if (top == null) {
top = node;
middle = node; } else {
top.left = node;
top = node; }
size++;
if (size % 2 == 0) {
middle = middle.left; //since we are pushing and hence move to the left. }
}
public T pop() { if (top == null) {
throw new EmptyStackException(); }
T item = top.item;
top = top.right;
// important, to not leak references. if (top != null) {
top.left = null; }
if (top == null) { middle = null;
}
if (size % 2 == 0) {
middle = middle.right; //we are popping hence reduce the size and move to the right
}
size--;
return item; }
public T getMiddle() { if (top == null) {
throw new EmptyStackException(); }
return middle.item; }

 } /*
Count triangles problem.*/ package sample;
import java.util.Arrays;
/**
* Created by arjun on 2014/12/10.
* 1. CountTriangles
* Count the number of triangles that can be built from a given set of edges.
* Task description
* A zeroindexed
array A consisting of N integers is given.
* A triplet (P, Q, R) is triangular if it is possible to build a triangle with sides of lengths A[P], A[Q] and A[R].
* In other words, triplet (P, Q, R) is triangular if 0 ≤ P < Q < R < N and:
* A[P] + A[Q] > A[R],
* A[Q] + A[R] > A[P],
* A[R] + A[P] > A[Q].
* For example, consider array A such that:
* A[0] = 10 A[1] = 2 A[2] = 5
* A[3] = 1 A[4] = 8 A[5] = 12
* There are four triangular triplets that can be constructed from elements of this array,
* namely (0, 2, 4), (0, 2, 5), (0, 4, 5), and (2, 4, 5).
* Write a function:
* class Solution { public int solution(int[] A); }
* that, given a zeroindexed
array A consisting of N integers, returns the number of
triangular triplets in this array.
* For example, given array A such that:
* A[0] = 10 A[1] = 2 A[2] = 5
* A[3] = 1 A[4] = 8 A[5] = 12
* the function should return 4, as explained above.
* Assume that:
* N is an integer within the range [0..1,000];
* each element of array A is an integer within the range [1..1,000,000,000].
* Complexity:
* expected worstcase
time complexity is O(N^2);
* expected worstcase
space complexity is O(1), beyond input storage (not counting the
storage required for input arguments).
* Elements of input arrays can be modified.
*/
public class CountTriangles {

 // O(n^2)
//https://codility.com/demo/results/demoHFCK86FBV/
public int solution(int[] A) {
Arrays.sort(A);
int ans = 0, n = A.length;
for (int i = 0; i < n 2;
i++) {
int k = 0; // k is init here
for (int j = i + 1; j < n 1;
j++) {
while (k < n && A[i] + A[j] > A[k]) {
k++;
}
ans += k j
1;
}
}
return ans;
}
/*
* * expected worstcase
time complexity is O(N*log(N));
* expected worstcase
space complexity is O(N), beyond input storage (not counting the storage required for input arguments).
* Elements of input arrays can be modified.
* perfect one*/
public int[] solution1(int[] A) throws Exception{
Arrays.sort(A);
for (int i = 2; i < A.length; i++) {
long sum = (long) A[i 2]
+ A[i 1]
;
if (sum > A[i]) return A;
}
return null;
}
// O(n^3)
//https://codility.com/demo/results/demoHVJ2YBD56/
/*public int solution(int[] A) {
Arrays.sort(A);
int ans = 0, n = A.length;
for (int i = 0; i < n; i++) {
for (int j = i + 1; j < n; j++) {
int sum = A[i] + A[j];
for (int k = j + 1; k < n && A[k] < sum; k++) {

 ans++;
}
}
}
return ans; }*/
public static void main(String[] args) {
int ans = new CountTriangles().solution(new int[]{10, 2, 5, 1, 8, 12}); int[] arr1 = new int[] {6,5,4,10,2,7};
int[] arr2 = new int[arr1.length];
try {
arr2 = new CountTriangles().solution1(arr1);
} catch (Exception e) {
// TODO Autogenerated
catch block
e.printStackTrace();
}
//System.out.println(ans);
for(int i = 0; i < 3; i++){
System.out.println(arr2[i]);
}
}
}
/*
Dependency resolution algorithm, detect cycle graph.
http://www.electricmonk.nl/log/2008/08/07/dependency-resolving-algorithm/
*/
We're keeping a list of all the nodes we've seen in the program above. But we've previously determined that a circular reference is occuring when we see a software package more than once, unless that software package has all its dependencies resolved. This means we don't need to remember the nodes we've seen if they are already resolved. This can save us some memory and processing time, since we only have to check a maximum of 'n' (where 'n' is the number of nodes in the graph) times each iteration. The way to go about this is to simply remove the node from the seen list once it has been resolved. We also rename our 'seen' list to 'unresolved' since that better describes what it does now:
  def​​ dep_resolve​(​node​,​ resolved​,​ unresolved​)​: unresolved.​append(​node​)
​for​​ edge ​in​​ node.​edges​:

  ​if​​ edge ​not​​ ​in​​ resolved: ​if​​ edge ​in​​ unresolved:
​raise​​ ​Exception​(​'Circular reference detected: %s -&gt; %s'​ % ​(​node.​name​, edge.​name))
dep_resolve​(​edge​,​ resolved​,​ unresolved​) resolved.​append(​node​) unresolved.​remove(​node​)
/*link - http://www.careercup.com/question?id=5724684365594624
Check if an integer array is arithmetic sequence.Example: 1, 2, 3, 4, 5, 6, 7, 8 => true
1, 3, 5, 7, 9 => true Array may not be sorted. */
 boolean​ isArithemticProgression​(​int​[]​ nums​)​ ​{
 ​if​(​nums​.​length ​<​=1​)
 return​ ​true​;
 ​int​ sum ​=​ 0​;
 ​int​ n ​=​ nums​.​length​;
 ​int​ diff ​=​ nums​[1​]​ ​-​ nums​[0​];
 ​int​ min ​=​ Integer​.​MAX_VALUE​;
 ​for​ ​(​int​ num ​:​ nums​)​ ​{
 min ​=​ Math​.​min​(​num​,​min​);
 sum ​+=​ num​;
 ​}
 ​if​(​sum​ ==​ ​(2​*​min​ +​ ​(​n​ -​ 1​)​ *​ diff​)*​n​/2​)​ ​{
 ​return​ ​true​;
 ​}
 ​return​ ​false​;
 ​}
/* BFS for graphs use the concept of visited node array in case of cycle or to keep track of visited and not visited in the array.
link - ​http://algorithms.tutorialhorizon.com/breadth-first-searchtraversal-in-a-graph/
 
 Approach:
1. For Graph as well we will use the Queue for per​form​ing the BFS.
2. We will use the boolean[] to keep a track of the nodes because unlike tree dur​ing tra​ver​sal we might keep mov​ing into the cir​cles by vis​it​ing same nodes repeatedly.
3. In our exam​ple we are using ​adja​cency List for the Graph Rep​re​sen​ta​tion​.
*/
public void BFS(int startVertex) {
boolean[] visited = new boolean[V];// V is the number of nodes in the graph Queue<Integer> s = new LinkedList<Integer>();
s.add(startVertex); while (!s.isEmpty()) {
int n = s.poll(); //retrieve and remove the head of this queue, or returns null if this queue is empty
 node.
} }
System.out.print(" " + n);
visited[n] = true;
Node head = array[n].head; //array => adjust neighbor list while (head != null) {
if (visited[head.dest] == false) {/if the head.dest not in visited s.add(head.dest); //head.dest gives the value of that
visited[head.dest] = true; }
head = head.next; }
/*Clone a linked list with next and random pointer, arbiter pointer , deep copy link - ​http://www.geeksforgeeks.org/clone-linked-list-next-arbit-pointer-set-2/ The idea is to use Hashing. Below is algorithm.
1. Traverse the original linked list and make a copy in terms of data.
2. Make a hash map of key value pair with original linked list node and copied linked list node.
3. Traverse the original linked list again and using the hash map adjust the next and random reference of cloned linked list nodes.
*/
// Actual clone method which returns head
 
 // reference of cloned linked list. public LinkedList clone( )
{
// Initialize two references, one with original // list's head.
Node origCurr = this.head, cloneCurr = null;
// Hash map which contains node to node mapping of
// original and clone linked list.
Map<Node, Node> map = new HashMap<Node, Node>();
// Traverse the original list and make a copy of that // in the clone linked list.
while (origCurr != null)
{
cloneCurr = new Node(origCurr.data); map.put(origCurr, cloneCurr); origCurr = origCurr.next;
}
// Adjusting the original list reference again. origCurr = this.head;
// Traversal of original list again to adjust the next
// and random references of clone list using hash map. while (origCurr != null)
{
cloneCurr = map.get(origCurr);
cloneCurr.next = map.get(origCurr.next); cloneCurr.random = map.get(origCurr.random); origCurr = origCurr.next;
}
//return the head reference of the clone list.
return new LinkedList(map.get(this.head)); }
link - ​http://www.geeksforgeeks.org/reverse-a-list-in-groups-of-given-size/ EXAMPLE
Linked List : 1->2->3->4->5->6->7->8->9->10->11 -> null
For k = 2
Return Value: 2->1->4->3->6->5->8->7->10->9->11 ->null For k = 3
Return value: 3->2->1->6->5->4->9->8->7->10->11 -> null //look for python example:
 
 http://www.geeksforgeeks.org/reverse-a-list-in-groups-of-given-size/
In the python for recursion call we write as “ self.pairWiseLink(next, k) “ //Java Solution
//package sample1;
//
//public class PairWiseLinkList {
// public static void pairWiseLink(Node head, int k){
 //
//
//
//
//
count value.
// next = current.next;
// current.next = prev;
// prev = current;
Node current = head;
Node next = null;
Node prev = null;
int count = 0;
while(count < k && current != null){ //same as reverse link list only maintain
// current = next;
// count++;
// }
/* next is now a pointer to (k+1)th node
Recursively call for the list starting from current. And make rest of the list as next of first node */
// // //
// // //}
if(next != null){
head.next = pairWiseLink(next, k);//here the reverse is called twice
}
Return prev; //this is the new head of the list.
checkpoint
}
/*find the maximum in the Binary Tree*/
public static int maxBinaryTree(Node root){ int max = Integer.MIN_VALUE; if(root != null){
int leftMax = maxBinaryTree(root.left); int rightMax = maxBinaryTree(root.right); if(leftMax > rightMax)
max = leftMax; else max = rightMax;
if(root.data > max)
max = root.data;
}
return max; }
/*Find element in Binary Tree*/

 public static boolean SearchTree(Node root, int data){ if(root != null)
return false; if(root.data == data)
return true;
return SearchTree(root.left, data) || SearchTree(root.right, data);
}
/* Find the size of the binary tree */
public static int sizeOfTree(Node root){
if(root == null) //check if root is null or not
return ​throw​ ​new​ ​IllegalArgumentException​(​"root is null hence no nodes"​);
int left, right;
if(root.left != null)
left = sizeOfTree(root.left); if(root.right != null)
right = sizeOfTree(root.right); return 1 + left + right;
}
/*link -
https://github.com/mission-peace/interview/edit/master/src/com/interview/tree/LevelOrderTra versalInReverse.java
Print the tree in level order in reverse order, level order in reverse order
take one stack and remove from the queue, add
Solution
* Maintain a stack and queue. Do regular level order traversal but
* put right first in the queue and den left to de queue. Instead of printing put the result * in stack. Finally print contents of the stack.
Time and space complexity is O(n) e.g 1
*23
* 4567
*
* Output should be 4 5 6 7 2 3 1
*/
public static void printTheTree(Node root){
Stack<Node> s = new Stack<Node>;
    
 Queue<Node> q = new LinkedList<Node>; q.add(root);
while(!q.isEmpty()){
root = q.poll(); //removing from the queue
if(root.right != null) q.add(root.right); //adding right, right to the queue if dey r not null
if(root.left != null) q.add(root.left);
s.push(root); //push the root 2 de stack }
while(!s.isEmpty()){
System.out.println(s.pop().data); //print de stack
} }
/*You are given a string. You have to eliminate the pairs (two same chars adjacent to each other).
RGBBGBGR --> RGGBGR-->RBGR
push first char into the stack den peek it if same den pop if not push*/
package sample1; import java.util.*;
public class EliminateTheAdjacentPairs {
public static String eliminatePairs(String a){
Stack<Character> stack = new Stack<Character>(); char[] ch = a.toCharArray();
stack.push(ch[0]);
for(int i = 1; i < a.length(); i++){
if(ch[i] == stack.peek()) //if same den pop from the stack stack.pop();
else
stack.push(ch[i]); //else push into stack.
}
return stack.toString();//returning it as to string. }
public static void main(String args[]){
System.out.println(EliminateTheAdjacentPairs.eliminatePairs("RGBBGBGR")); }
}
checkpoint
/*a arjun mantri -> aarjunmantri

 moved de two spaces from arjun mantri to front. Take for loop from back and den check for the space if not den put de char to de count location. Now at de end the count will be at front and hence include dat many space in de front. de value of count is number of spaces. */ public class MoveSpaceTofront {
public static String moveSpaceToFront(String a){ int count = a.length() - 1;
char[] ch = a.toCharArray();
for(int i = a.length() - 1; i >= 0; i--){
if(ch[i] != ' ')
ch[count--] = ch[i];//putting char to the count location if space.
}
while(count >= 0)
ch[count--] = ' '; return new String(ch);
}
public static void main(String args[]){
String a = new String (MoveSpaceTofront.moveSpaceToFront("a arjun
mantri"));
System.out.println(a); }
}
//http://www.geeksforgeeks.org/delete-n-nodes-after-m-nodes-of-a-linked-list/ //package sample1;
//
//public class DeleteNnodeM {
// public static void deleteNodes(Node curr,int M, int N){
// while(curr != null){
// for(int i = 0; i < M; i++){//to skip to M nodes
// curr = curr.next;
// }
// Node prev = curr;//need to get the previous location
// for(int i = 0; i < N; i++){
// curr = curr.next;
// }
// prev.next = curr;//delete the nodes in between.
// }
// } //}
/*Implement stack and queue using the LinkList. stack using linklist. queue using linklist */

 //package sample1;
//
//public class StackAndQueueLinkedList {
// Node top = null;
// int length = 0;
// public static void push(int data){
// Node temp = new Node(data);//store in the temp node
// temp.next(top);//point it to top of the stack
// top = temp; //den point top to temp
// length++; //lenght to give de length of list
// } //
// public static int pop(){
// if(top == null)//empty stack
// int a = top.data;
// top = top.next;
// length--;
// return a;
// }
// //dis for queue
// Node rear = null, front = null;
// public static void add(int data){
// Node node = new Node(data);
// if(rear == null) {
// front = node;
rear = node
// }
// else {
// rear.next = node;
// rear = node;
// }
// length++;
// }
// public static int remove(){
// if(isEmpty())
// throw new Exception("queue is Empty");
// int a = front.data;
// front = front.next;
// if(isEmpty())
// rear = null //when only one element is der in queue den v shld set it 2 null
// return a;
// } //}

 ////link - ​http://www.crazyforcode.com/merge-linked-list-linked-list-alternate-positions/ //take two pointers and alternately move from one list to other list.
//​Time compleixty: O(N)
//public class MergeAlternateLinkList {
// Node first_next, sec_next;
// Node p1 = head1;
// Node p2 = head2; //
// public static void mergeAlternate(Node head1, Node head2){
  //
//
//
//
//
//
//
//
//
// } //
while(p1 != null && p2 != null){ first_next = p1.next;
sec_next = p2.next;
p2.next = first_next; p1.next = p2;
p1 = first_next; p2 = sec_next;
p2 = sec; //setting the head again.
//}
/* Minimum depth of binary Tree
link - ​http://www.geeksforgeeks.org/find-minimum-depth-of-a-binary-tree/​ */
int minDepth(Node root){
       // Corner case. Should never be hit unless the code is
    // called on root = NULL
if(root == null) return 0;
​// Base case : Leaf Node. This accounts for height = 1. if(root.left == null && root.right == null)
return 1;
       // If left subtree is NULL, recur for right subtree
if(root.left != null) //if left not null den go to right since we got not null on left, min is on right
return minDepth(root.right) + 1;
       // If right subtree is NULL, recur for right subtree
if(root.right != null) //if right not null den go to left since we got not null on right, min is on left
return minDepth(root.left) + 1;
return Math.min(minDepth(root.right), minDepth(root.left)) + 1;
 
 }
# Python program to find minimum depth of a given Binary Tree
# Tree node
class Node:
    def __init__(self , key):
        self.data = key
        self.left = None
        self.right = None
def minDepth(root):
    # Corner Case.Should never be hit unless the code is
    # called on root = NULL
    if root is None:
return 0
    # Base Case : Leaf node.This acoounts for height = 1
    if root.left is None and root.right is None:
return 1
    # If left subtree is Null, recur for right subtree
    if root.left is None:
        return minDepth(root.right)+1
    # If right subtree is Null , recur for left subtree
    if root.right is None:
        return minDepth(root.left) +1
    return min(minDepth(root.left), minDepth(root.right))+1
# Driver Program
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
print minDepth(root)
/**
/* Level order tree traversal in Spiral manner. This can be done using two stacks*/

      * Two stack to print in spiral way
*/
​public​ ​void​ ​spiralWithTwoStack​(Node ​root​) { ​if​ (root ​==​ ​null​) {
​return​; }
​Stack<​Node​>​ s1 ​=​ ​new​ ​Stack<>​(); ​Stack<​Node​>​ s2 ​=​ ​new​ ​Stack<>​(); s1​.​push(root); //push root into s1 first.
//check if both de stack r empty or not.
//v take two stacks push left into S1 den 2 right
​while​ (​!​s1​.​isEmpty() ​||​ ​!​s2​.​isEmpty()) { ​while​ (​!​s1​.​isEmpty()) { //check for S1
root ​=​ s1​.​pop();//POP S1 System​.​out​.​print(root​.​data ​+​ ​" "​); ​if​ (root​.​left ​!=​ ​null​) {
s2​.​push(root​.​left);//PUSH S2 }
​if​ (root​.​right ​!=​ ​null​) { s2​.​push(root​.​right);//PUSH S2
} }
//in case of S2 push first right and den left ​while​ (​!​s2​.​isEmpty()) {//CHECK FOR S2
root ​=​ s2​.​pop();//POP S2 System​.​out​.​print(root​.​data ​+​ ​" "​); ​if​ (root​.​right ​!=​ ​null​) {
s1​.​push(root​.​right);//PUSH S1 }
​if​ (root​.​left ​!=​ ​null​) { s1​.​push(root​.​left);//PUSH S1
} }
} }

 //Panagram - which contains all the character in a sentence.
//​We promptly judged antique ivory buckles for the next prize - Yes panagram //arjun - not a pangram.
//just know the ascii value of z-a and den count++ for every character found //now if the count length is greater den ALPHA_LEN den yes its panagram. import java.io.*;
import java.util.*;
public class Solution {
public static void main(String[] args) {
Scanner kbd = new Scanner(System.in);
final char[] C = kbd.nextLine().toLowerCase().toCharArray();
final int N = C.length;
boolean isPangram = false;
final int ALPHA_LEN = 'z' - 'a' + 1; if (N >= ALPHA_LEN){
int count = 0;
final boolean[] alpha = new boolean[ALPHA_LEN]; for(int i = N-1; i >= 0; --i){
char c = C[i];
if (c >= 'a' && c <= 'z' && !alpha[c -= 'a']){
alpha[c] = true;
if (++count >= ALPHA_LEN){
isPangram = true;
break; }
}/* else if (count + i+1 < ALPHA_LEN){ break;
}*/ }
}
System.out.print(isPangram ? "pangram" : "not pangram"); }
}
/* insert a element in to linklist */
 /* function to insert a new_node in a list. */
 void sortedInsert(Node new_node)
 {

  Node current;
 /* Special case for head node */
 if (head == null || head.data >= new_node.data)
 {
 new_node.next = head;
 head = new_node;
 }
 else {
 /* Locate the node before point of insertion. */
 current = head;
 while (current.next != null &&
 current.next.data < new_node.data)
 }
current = current.next;
 new_node.next = current.next;
 current.next = new_node;
  }
/*Deadlock describes a situation where two or more threads are blocked forever, waiting for each other. Deadlocks can occur in Java when the synchronized keyword causes the executing thread to block while waiting to get the lock, associated with the specified object. Since the thread might already hold locks associated with other objects, two threads could each be waiting for the other to release a lock. In such case, they will end up waiting forever. - See more at: http://www.java2novice.com/java-interview-programs/thread-deadlock/#sthash.FLTy9qyJ.dp uf
2. good example best one:-.
http://javarevisited.blogspot.com/2010/10/what-is-deadlock-in-java-how-to-fix-it.html
*/
package com.java2novice.algos; public class MyDeadlock {
String str1 = "Java"; String str2 = "UNIX";
Thread trd1 = new Thread("My Thread 1"){ public void run(){
while(true){ synchronized(str1){
synchronized(str2){ System.out.println(str1 + str2);
   
 } }
} }
};
Thread trd2 = new Thread("My Thread 2"){ public void run(){
while(true){ synchronized(str2){
synchronized(str1){ System.out.println(str2 + str1);
} }
} }
};
public static void main(String a[]){ MyDeadlock mdl = new MyDeadlock(); mdl.trd1.start();
mdl.trd2.start();
} }
/* Multithreading and Synchronization: */
http://javarevisited.blogspot.com/2011/04/synchronization-in-java-synchronized.html
/* more about synchrnization */
http://javarevisited.blogspot.com/2011/04/synchronization-in-java-synchronized.html
/* Lowest common ancestor in Binary search Tree, BST */
public static Node LCA(Node node, int n1, int n2){ if (node == null) {
return null; }
// If either n1 or n2 matches with root's key, report
// the presence by returning root (Note that if a key is
// ancestor of other, then the ancestor key becomes LCA if (node.data == n1 || node.data == n2)
return node;
// If both n1 and n2 are smaller than root, then LCA lies in left if (node.data > n1 && node.data > n2) {
return lca(node.left, n1, n2);
  
 }
// If both n1 and n2 are greater than root, then LCA lies in right if (node.data < n1 && node.data < n2) {
return lca(node.right, n1, n2); }
return node; }
/* Maximum difference between node and its ancestor in Binary Tree. - O ( N )
Get the minimum value from the left and right of tree and ......go recursively until v find de min..... to get the max diff get the minmum and den subtract wth max value in de tree*/
public static void maxDiffUtil(Node root){ //util method. int res = Integer.Min_Value;
maxDiff(root, res); }
public static int maxDiff(Node root, int res){
/* Returning Maximum int value if node is not there (one child case) */
if(root == null) return null;
/* If leaf node then just return node's value */ if(root.left == null && root.right == null)
return root.data
/* Recursively calling left and right subtree for minimum value */
int val = Math.min(maxDiff(root.left, res), maxDiff(root.right, res)); //getting de min of left and right
/* Updating res if (node value - minimum value from subtree) is bigger than res */
res = Math.max(res, root.data - val); //get the max until now and store in res, getng
de difference as well from current root and value.
return Math.min(val, root.data); //return de min value got so far. System.out.println(“Maximum difference is : ” + res); ..printing the max diff
}
/**

 * Java Program to Implement Flood Fill Algorithm. der r two apporach, first one is 4 connected in which a point is given and v hav to fill above, below, left and right of the point. And also 8 connected in which the diganols are also filled. Now v hav to fill wth ‘O’ as obstacles and ‘P’ as the point to be filled with ‘W’. So the
left -> r,c-1
right -> r,c+1
above -> r+1,c
below -> r-1,c
in dis case r and c are the starting point for the fill to start from.
link - ​http://www.sanfoundry.com/java-program-flood-fill-algorithm/
youtube - ​https://www.youtube.com/watch?v=kV-l8Gnwtkk
**/
public static void floodFill(int ar[][], int r, int c) {
if(a[r][c] == ‘P’) {
arr​[​r​][​c​]​ =​ ​ ​'W'​; floodFill(a, r, c+1); floodFill(a, r, c-1); floodFill(a, r+1, c); floodFill(a, r-1, c); display(a);
} }
public static void display(int a[][]){
for (int i = 1; i < arr.length - 1; i++)
{
for (int j = 1; j < arr[i].length - 1; j++)
System.out.print(arr[i][j] +" "); System.out.println();
} }
/* Reverse a stack using recurssion. In this case v will use two methods one for pop and from this pop den insert an element into the other stack.*/
import java.util.Stack;
public class ReverseWithoutExtra {
static class ModifiedStack extends Stack<Integer>{
private void pushToBottom(int a){ //dis is fr push method
if(this.isEmpty()){
   
 } }
this.push(a);
return; }
int temp = this.pop(); this.pushToBottom(a); this.push(temp);
}
public void reverse(){ // this for poping method.
if(this.isEmpty()) return;
int temp = this.pop(); this.reverse(); this.pushToBottom(temp);
public static void main(String[] str){
ModifiedStack stack = new ModifiedStack(); stack.push(1);
stack.push(2);
stack.push(3);
stack.push(4);
System.out.println(stack);
stack.reverse();
System.out.println(stack);
}
/* FizzBuzz problem */
public class fizzbuzz {
public static void main(String[] args){ for(int i = 1; i <= 100; i++){
String test = "";
test += (i % 3) == 0 ? "fizz" : "";
test += (i % 5) == 0 ? "buzz" : ""; System.out.println(!test.isEmpty() ? test : i);
} }
​}
   
 /* Quicksort. Take the pivot as the middle element and den sort such that all the element to the left are less den pivot and element to the right are greater den pivot.
- See more at: http://www.java2novice.com/java-sorting-algorithms/quick-sort/#sthash.V8pam0dU.dpuf
*/
public static void quickSort(int lowerIndex, int higherIndex) int i = 0;
int j = a.length();
int pivot = a[ i + ( j - i ) / 2];
/**
* In each iteration, we will identify a number from left side which
* is greater then the pivot value, and also we will identify a number * from right side which is less then the pivot value. Once the search * is done, then we exchange both numbers.
*/
while( i <= j ) {
while ( a[ i ] < pivot ){
i++; }
while( a[ j ] > pivot){ j--;
}
if(i <= j){
exchangeNumbers(i, j); i++;
j--;
} }
// call quickSort() method recursively if( lowerIndex < j )
quickSort(lowerIndex , j); if(i < higherIndex)
quickSort(i , higherIndex);
}
/* If two trees are structurally identical or not. Check for the right1, right2 of the tree and also left1,
left2 */
public static boolean identiticalTree(Node root1, Node root2){ if(root1 == null && root2 == null)

 return true;
if(root1 == null || root2 == null)
return false;
return identiticalTree(root1.right, root2.right) && identiticalTree(root1.left, root2.left);
}
/*Diameter or width of binary tree which is number of nodes between left and right leaf nodes.
link - ​http://www.geeksforgeeks.org/diameter-of-a-binary-tree/
*/
class height{ int h;
}
public static int diameterCal (Node root,Height height){ Height lh = new Height();
Height rh = new Height();
if(root == null){ height.h = 0;
return 0; }
lh.h++; //incremeting the hght here only hence no need to call the recusrsive again and again reducing the complexity to O ( N )
rh.h++;
ldiameter = diameterCal(root.left, lh); rdiameter = diameterCal(root.right, rh);
height.h = Math.max(lh.h, rh.h) + 1;
return Math.max(lh.h + rh.h + 1, Math.max(ldiameter, rdiameter));
}
/*Edit Distance dynammic programming*/ package sample;
public class EditDistanceDP {
public static int editDistance(char[] row, char[] col){
int[][] temp = new int[row.length+1][col.length+1]; for(int i = 0; i < temp[0].length; i++){
 
 temp[0][i] = i;//dis to fill the very frst row of it. }
for(int i = 0; i < temp.length; i++){
temp[i][0] = i;//dis to fill the very frst col of it.
}
for(int i = 1; i <= row.length; i++)
for(int j = 1; j <= col.length; j++){
if(row[i-1] == col[j-1])//cmparng the same element hence storing de diagonal value into temp
temp[i][j] = temp[i-1][j-1];
else //storing the min of the three into the temp array
temp[i][j] = Math.min(temp[i-1][j-1], Math.min(temp[i][j-1],temp[i-1][j])) + 1;
}
return temp[row.length][col.length];//return the last value which is the
operation to convrt into one string to other }
public static void main(String args[]){ String str1 = "azced";
String str2 = "abcdef";
System.out.println(EditDistanceDP .editDistance(str1.toCharArray(),
str2.toCharArray())); }
}
/*Longest Palindromic Subsequence
Link - ​https://www.youtube.com/watch?v=_nCsPn7_OgI */
package sample1;
public class PalindromecSubsequence { public int calculate1(char []str){
int T[][] = new int[str.length][str.length]; for(int i=0; i < str.length; i++){
T[i][i] = 1;//set all the diagonls as 1...since longest will be 1 only. }
for(int l = 2; l <= str.length; l++){ for(int i = 0; i < str.length-l + 1; i++){
int j = i + l - 1;
if(l == 2 && str[i] == str[j]){// if aa den max length is 2 hence set t[i][j] as 2
T[i][j] = 2;
 
 }else if(str[i] == str[j]){//same start and end.
T[i][j] = T[i + 1][j-1] + 2;//"b d b" since b and b are same hence max + 2
}else{
T[i][j] = Math.max(T[i + 1][j], T[i][j - 1]);//since it does not match hence max of
two.
}
} }
return T[0][str.length-1];//returning the 0th row and last column whch is de max length }
public static void main(String args[]){
PalindromecSubsequence lps = new PalindromecSubsequence();
String str = "agbdba";
int r2 = lps.calculate1(str.toCharArray()); System.out.print(" " + r2);
} }
/* Insert into binary search tree */ public static void Insert(int data){
if(root == null){
root = new Node();
root.setData(data); root.setLeft(null); root.setRight(null);
} else {
} else
}
return root; }
if(data < root.data){ Insert(root.Left, data);
Insert(root.right, data);
/* Given an algorithm counting the number of BST’s possible with n nodes. Also called as Catalan number , This is done using DP in which we multiple the previous number of possible BST’s and den add to the current one.
link - https://github.com/mission-peace/interview/blob/master/src/com/interview/dynamic/CountNu mberOfTreesInBST.java
link - ​https://www.youtube.com/watch?v=YDf982Lb84o
   
 */
public static void countTrees(int n){ //where n is the number of keys the BST can be formed. int T[ ] = new int [n+1];
T[0] = 1;
T[1] = 1;
for(int i = 2; i <= n; i++){
for(int j = 0; j < i ; i++){
T [ i ] += T [ j ] * T [ i - j - 1] //Now here v take previous number of keys
and den mutiple and add to de existing one. }
} }
/* Doubly link list to Binary search tree (ddl to bst)
building the left subtree first and den recursively again building right subtree, calculate the middle */
public static void constructBSTUtil(Node head, int start, int end){ //de head is de doubly list head
Node curr = head;
int len = 0; while(curr.next != null){
len++;
curr = curr.next; }
return public static void constructBST(head, 0 , len); }
public static void constructBST(Node head, int start, int end){ if(start > end)
return null;
int mid = start + (end - start)/2;
//building the left subtree first and den recursively again building right subtree Node left = constructBST(head, start, mid - 1);//making mid as the root. Node root = new Node(head.data);
root.left = root;
if(head.next != null){
head.data = head.next.data;
head.next = head.next.next; }
root.right = constructBST(head, mid + 1, end); //construct the right subtree
return root; //returning the head of the root. }

 /* Longest common subsquence....if two character at a ith location in string are ​not same den take max of left and above of ith location, if the two character at ith location in the string are the same den take 1 + diagonal value, evry time compare with max and if greater den max store in the max
LCS for input Sequences “ABCDGH” and “AEDFHR” is “ADH” of length 3. .*/
public static int longestCommonSubsequence (char [ ]s1, char [ ]s2){ int max = 0;
int[ ][ ] temp = new int[s1.length + 1] [s2.length + 1]; for(int i = 1; i < temp.length; i++){
for(int j = 1; j < i; i++){ if(s1 [ i ] == s2 [ j ])
max = temp[ i-1 ][ j-1 ] + 1;//if char are same den diagonal + 1 else
max = Math.max( temp[ i ][ j - 1 ], temp[ i-1 ][ j ] ); //if differnt
max of left and above.
if(temp[ i ][ j ] > max)
max = temp [ i ] [ j ]; }//end of inner for loop;
}//end of outer for loop.
return max; }
// Java program to find the maximum repeating number. we take the mod of the numbers in the array and den take the maximum element’s index which is the maximum repeating count of that number. */
import java.io.*;
class MaxRepeating {
// Returns maximum repeating element in arr[0..n-1]. // The array elements are in range from 0 to k-1 static int maxRepeating(int arr[], int n, int k)
{
// Iterate though input array, for every element // arr[i], increment arr[arr[i]%k] by k
for (int i = 0; i< n; i++)
arr[(arr[i]%k)] += k; //important step to get that.
// Find index of the maximum repeating element int max = arr[0], result = 0;
for (int i = 1; i < n; i++)
{
if (arr[i] > max)

 } }
{
max = arr[i];
result = i; }
}
// Return index of the maximum element
return result; }
/*Driver function to check for above function*/ public static void main (String[] args)
{
int arr[] = {2, 3, 3, 5, 3, 4, 1, 7};
int n = arr.length;
int k=8;
System.out.println("Maximum repeating element is: " +
maxRepeating(arr,n,k));
/* power set problem.
link - ​http://stackoverflow.com/questions/1670862/obtaining-a-powerset-of-a-set-in-java add head, set to newset and den newset, set to sets */
package sample1;
//O(2^n)
import java.util.*;
public class PowerSet {
public static <T> Set<Set<T>> powerSet(Set<T> originalSet) { Set<Set<T>> sets = new HashSet<Set<T>>();
if (originalSet.isEmpty()) {
sets.add(new HashSet<T>());
return sets; }
List<T> list = new ArrayList<T>(originalSet);//settng list to origianl list initially. T head = list.get(0);
Set<T> rest = new HashSet<T>(list.subList(1, list.size()));//remaining list
for (Set<T> set : powerSet(rest)) {//iterating on the rest of the list
Set<T> newSet = new HashSet<T>(); //in every loop newset is declared. System.out.println(" set "+set);
newSet.add(head);//add head first
newSet.addAll(set);//every time adding set
System.out.println(" newset "+newSet); sets.add(newSet);
 
 sets.add(set);
System.out.println(" sets "+sets); }
return sets; }
public static void main(String args[]){
Set<Integer> mySet = new HashSet<Integer>(); mySet.add(1);
mySet.add(2);
mySet.add(3);
for (Set<Integer> s : PowerSet.powerSet(mySet)) {
//System.out.println(s); }
} }
/*Max heap sort, max heapify. In this the root is always greater den its child. we first compare the left node is greater den parent if yes replace and den right node is greater den max value(which we got from max of left and parent) if yes set it to the max value. Now check if the.
link - ​https://www.youtube.com/watch?v=ScF985Y4DJc */
public static void heapify(int[] a){
for (int i = a.length()/2; i >= 0; i--)
maxHeap(a, i);
}
public static maxHeap(int[] a, int i){ //a is the array and i is node from which we want to do maxheapify.
int left = 2i;
int right = 2i + 1;
int max = 0;
if(left <= a.length() && a[left] > a[i]) //first is to chck if left is in the tree or not and den
to chck if the left is greater den the parent also
max = left; //storing the max index to max
if(right <= a.length() && a[right] > a[max]) //frst chck if right is in tree or not and den chck if right is greater den both the left and de parent
max = right; if(max != i){
 }
swap(a, max, i); //swapping the elements not in place.
maxHeap(a, max); //recursively callng to sort as maxheap wth new max }

 /*Find Nth largest Element in BST*/
Public static treeNode findNthLargest(treeNode root, int n, int count) {
if(root == null || count >= n) return;
//search in right subtree first as we need to find Nth Largest //if Nth smallest we need to find search in left subtree first
findNthLargest(treeNode root.right, n, count);
// Increment count of visited nodes
//if not found in right subtree check if root is Nthlargest or not
if(++count == n){// Increment count of visited nodes System.out.println(root.data);
return;
}
//if not found in right subtree search left subtree findNthLargest(treeNode root.left, int n, int count); }
/* Infix to postfix using stacks. If operand den append to de result if operator den check precedence wth the operator in the stack if greater den push if less pop de element from de stack and append to the result. If ‘ ( ‘ den push to stack and when u encounter next ‘ ) ‘ pop untill the first ‘ ( ’ brackt */
public static String convertToPostfix(String a){ Stack<Character> s = new Stack<>(); StringBuffer result = new StringBuffer(); Char[] ch = a.toCharArray();
for(int i = 0; i < ch.length(); i++){ if( isOperand(ch[ i ]) )
{
result.append(ch [ i ]);
}
else if(ch[ i ] == ‘(’ ) {
s.push(ch[ i ]); }

 else if(ch[ i ] == ‘)’) {
while(!s.isEmpty() && s.peek() != ‘(’ ) result.append(s.pop())
s.pop() //only popping the opening brckt }
else {
if(!s.isEmpty() && Prec(ch [ i ]) < Prec(s.peek()) )//if char at stack is greater pop and append to the result.
} }
while(!s.isEmpty()) {
result.append(s.pop()); else
s.push(ch [ i ]);
result.append(s.pop()); }
return result.toString(); }
// A utility function to check if the given character is operand
public static int isOperand(char ch)
{
    return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');
}
// A utility function to return precedence of a given operator
// Higher returned value means higher precedence
public static int Prec(char ch)
{
    switch (ch)
    {
    case '+':
    case '-':
return 1;
    case '*':
    case '/':
return 2;
    case '^':
        return 3;
}
return -1; }
    
 binary heap over the bst for priority queue.
http://www.geeksforgeeks.org/why-is-binary-heap-preferred-over-bst-for-priority-queue/
1. Finding minimum and maximum are not naturally O(1), but can be easily implemented in O(1) by keeping an extra pointer to minimum or maximum and updating the pointer with insertion and deletion if required. With deletion we can update by finding inorder predecessor or successor.
2. Inserting an element is naturally O(Logn)
3. Removing maximum or minimum are also O(Logn)
4. Decrease key can be done in O(Logn) by doing a deletion followed by insertion. See
this​ for details.
So why is Binary Heap Preferred for Priority Queue?
● Since Binary Heap is implemented using arrays, there is always better locality of reference and operations are more cache friendly.
● Although operations are of same time complexity, constants in Binary Search Tree are higher.
● We can build a Binary Heap in O(n) time. Self Balancing BSTs require O(nLogn) time to construct.
● Binary Heap doesn’t require extra space for pointers.
● Binary Heap is easier to implement.
● There are variations of Binary Heap like Fibonacci Heap that can support insert and
decrease-key in Θ(1) time.
/*Kth smallest or largest element in an array. Use quick select in which we pass kth index to the parition function and den it returns pivot, and if the pivot index is same as kth den that is element we are searching */ http://www.geeksforgeeks.org/kth-smallestlargest-element-unsorted-array/
public static int kthLargest (int [ ] a, int l, int r ){ if( k > 0 && k <= r - l - 1 ){
int pos = partition (a, l , r);
if (pos - l == k - 1) //if the postion is the same kth den we found it. return arr[pos];
if (pos-l > k-1) // If position is more, recur for left subarray return kthSmallest(a, l, pos-1, k);
// Else recur for right subarray
return kthSmallest(arr, pos+1, r, k-pos+l-1);
}
   
 }
public int partition(int [ ] a, int l, int r ){
int x = a[ r ];
int i = l;
for(int j = l; j <= r -1; j++){
if(a[ j ] <= x) {
swap(a[ i ], a[ j ]);
i++; }
}//end of for loop swap(a[ i ], a[ r ] ); return i;
}
Since array is sorted, the first thing clicks into mind is binary search, but the problem here is that we don’t know size of array.
If the array is infinite, that means we don’t have proper bounds to apply binary search. So in order to find position of key, first we find bounds and then apply binary search algorithm.
Let low be pointing to 1st element and high pointing to 2nd element of array, Now compare key with high index element,
->if it is greater than high index element then copy high index in low index and double the high index.
->if it is smaller, then apply binary search on high and low indices found. */
def binarySearch (a, l, h, key):
mid = ( l + h ) / 2 if l <= h:
if a[mid] == key: return mid
if(key < a[ mid ]) :
return binarySearch(a, 0, mid-1, key)
return binarySearch(a, mid+1, len(a), key) return -1
def findTheElement(a, key): l, h, val = 0, 1, a[0]
if val < key: l=h
h=h*2
return binarySearch(a, l, h, key)
if ‘__name__’ == ‘__main__’
/*Find position of an element in a sorted array of infinite numbers

 findTheElement(a, 100) //find 100 in list of unknkown size
/* Immutable class in java example */
public class ImmutableClass { private final String mobile;
private final String number;
public ImmutableClass(String mobile, String number){ this.mobile = mobile;
this.number = number; }
public String getterMobile(){ return mobile;
}
public String getterNumber(){
return number; }
}
/* The only difference between ​offer​ and ​add​ is the interface they belong to. ​offer belongs to ​Queue<E>​, whereas ​add​ is originally seen in ​Collection<E>​ interface. Apart from that both methods do exactly the same thing - insert the specified element into priority queue. */
/* stack using two queue. In this if q1 is empty push element into it else dequeue from q1 and enqueue into q2. Now add the new element to q1 and again add back all the elements from q2 to q1.*/
public static void push(int element){
Queue<Integer> q1 = new LinkedList<Integer>(); Queue<Integer> q2 = new LinkedList<Integer>(); if(q1.isEmpty()){
q1.add(element); }
       else { from q2.
//remove q1 to add to q2, add new elem to q1 and put ol elem back to q1
while(!q1.isEmpty()) q2.add(q1.remove());
q1.add(element); while(!q2.isEmpty())

 q1.add(q2.remove());
 } }
public static int pop(){ if(q1.isEmpty())
throw​​ ​new​​ N​ oSuchElementException​(​"Underflow Exception"​)​; //important else return q1.remove();
}
/* Queue using two stack. If s1 is empty den push into s1 else pop all de elem from s1 and push into s2, add new elem to s1, now push all de elem from s2 to s1 */
public static void add(int element){ Stack<Integer> s1 = new Stack<Integer>(); Stack<Integer> s2 = new Stack<Integer>(); if(s1.isEmpty())
s1.push(element); else{
   } }
while(!s1.isEmtpy()) s2.push(s1.pop());
s1.push(element); while(!s2.isEmpty())
s1.push(s2.pop());
  public static int remove(){ if(s1.isEmpty())
throw new NoSuchElementException(“Underflow exception”); return s1.pop();
}
/ * *
     * Uses bottom up DP to find the edit distance /
public int dynamicEditDistance(char[] str1, char[] str2){ int temp[][] = new int[str1.length+1][str2.length+1];
for(int i=0; i < temp[0].length; i++){
      
  temp[0][i] = i; }
for(int i=0; i < temp.length; i++){ temp[i][0] = i;
}
for(int i=1;i <=str1.length; i++){ for(int j=1; j <= str2.length; j++){
if(str1[i-1] == str2[j-1]){ temp[i][j] = temp[i-1][j-1];
}else{
temp[i][j] = 1 + min(temp[i-1][j-1], temp[i-1][j], temp[i][j-1]);
} }
}
printActualEdits(temp, str1, str2); return temp[str1.length][str2.length];
}
/* Maximum sum such that no two elements are adjacent. Take the Maximum of ( Add the current number to the exclusive and inclusive). Now set the exclusive to previous value of inclusive value.
3 2 7 10 should return 13 (sum of 3 and 10)
link -
http://www.geeksforgeeks.org/maximum-sum-such-that-no-two-elements-are-adjacent/ youtube - ​https://www.youtube.com/watch?v=UtGtF6nc35g
*/
public static int maximumSumNotAdjacent(int[ ] a){ int excl = 0;
int incl = a [ 0 ];
for(int i = 0; i < a.length(); i++){
excl_new = (incl > excl) ? incl : excl; incl = Math.max(a[ i ] + excl, incl); excl = excl_new;
}
return ((incl > excl) ? incl : excl ); }
                        
 visa
● http://www.geeksforgeeks.org/find-number-of-islands/
● http://www.geeksforgeeks.org/maximum-profit-by-buying-and-selling-a-share-at-most-t wice/
//link - ​https://rosettacode.org/wiki/Power_set#Python //PowerSet in python:
def​​ powersetlist​(​​s​)​​:
r = ​[[]] ​for​​ e ​in​​ s:
​print​​ ​"r: %-55r e: %r"​ % ​(​​r,e)​
r += ​[​​x+​[​​e​]​​ ​for​​ x ​in​​ r​] //here taking the combination of e with x ​return​​ r
​print​​ ​"\npowersetlist(%r) =\n %r"​ % (​ ​​s, powersetlist​(​​s​)) Output:
r: [[]]
r: [[], [0]]
r: [[], [0], [1], [0, 1]]
r: [[], [0], [1], [0, 1], [2], [0, 2], [1, 2], [0, 1, 2]] e: 3
powersetlist([0, 1, 2, 3]) =
[[], [0], [1], [0, 1], [2], [0, 2], [1, 2], [0, 1, 2], [3], [0, 3], [1, 3], [0, 1, 3], [2, 3], [0,
2, 3], [1, 2, 3], [0, 1, 2, 3]]
//Sieve of Eratosthenes. Find prime number for given limit of numbers. // Return boolean list of prime numbers
//​O(​n​ log log ​n)​
        e: 0 e: 1
  e: 2
       ​private​​ ​int​​[]​ calcPrimes​(i​ nt​​ N)​
1.
  ​{
2.
  ​int​​[]​ arr ​=​ ​new​​ ​int​​[​N ​+​ ​1​]​;
3.
  ​for​​ ​(​int​​ i ​=​ ​2​;​ i ​<=​ ​Math​.​sqrt​(​N​)​;​ i​++​)
4.
  ​{
5.
  ​if​​ ​(​arr​[​i​]​ =​ =​ ​0)​ //initially ol are set to zero only
6.
  ​{

 7.
  ​for ​(​int j ​= i ​* i​; j ​<= N​; j ​+= i​)//here settng multiple of
 2, 3, 4 and so on and setting it to 1
8.
  ​{
9.
  arr​[​j​]​ =​ ​ ​1​;
10.
  ​}
11.
  ​}
12.
  ​}
13.
  ​return​​ arr​;
14.
  ​}
15.
  ​/** Function to get all primes **/
16.
  ​public​​ ​void​​ getPrimes​(​int​​ N​)
17.
  ​{
18.
  ​int​​[]​ primes ​=​ calcPrimes​(​N)​ ​;
19.
  display​(​primes​);​ //or display here itself
20.
  ​}
21.
  public​​ ​void​​ display​(​int​​[]​ primes​)
22.
  ​{
23.
  ​System​.​out​.p​ rint​(​"​\nP​​ rimes = "​)​;
24.
  ​for​​ ​(​int​​ i ​=​ ​2​;​ i ​<​ primes.​length​;​ i​++​)
25.
  ​if​​ ​(​primes​[i​ ​]​ ​==​ ​0​)
26.
  ​System​.o​ ut​.p​ rint​(​i ​+​" "​)​;
27.
  ​System​.​out​.p​ rintln​();​
28.
  ​}
Powertset:
https://www.quora.com/How-do-I-find-powerset-for-a-given-set-in-Java
 1. 2. 3. 4. 5.
// Copyright (C) 2014 Toby Thain, toby@telegraphics.com.au
object​​ ​Powerset​ ​{
​def​​ powerset​[​T​](​s:​ ​Set​[​T​]):​Set​[​Set​[​T​]]​ ​=​ ​{ ​if​​(​s​.​isEmpty​)

 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18.
​Set​(​Set​()) ​else
s​.​flatMap​(​ e ​=>​ ​{
val ps ​=​ powerset​(​s -​ ​ e​) ps ​++​ ps​.​map​(​_ ​+​ e​)
​}​ ​) ​}
​def​​ main​(​args​:​Array​[​String]​ )​ {​
println​(​powerset​(​Set​(​'apple, '​banana,​ ​ ​'orange))) }
}
//​http://www.geeksforgeeks.org/find-pythagorean-triplet-in-an-unsorted-array/ //​We can solve this in O(n​2​) time by sorting the array first.
1) Do square of every element in input array. This step takes O(n) time.
2) Sort the squared array in increasing order. This step takes O(nLogn) time.
3) To find a triplet (a, b, c) such that a = b + c, do following.
1. Fix ‘a’ as last element of sorted array.
2. Now search for pair (b, c) in subarray between first element and ‘a’. A pair (b, c) with
given sum can be found in O(n) time using meet in middle algorithm discussed in
method 1 of ​this ​post.
3. If no pair found for current ‘a’, then move ‘a’ one position back and repeat step 3.b.
static boolean isTriplet(int arr[], int n) {
// Square array elements for (int i=0; i<n; i++)
arr[i] = arr[i]*arr[i];
// Sort array elements Arrays.sort(arr);
// Now fix one element one by one and find the other two // elements
for (int i = n-1; i >= 2; i--)
{
// To find the other two elements, start two index
// variables from two corners of the array and move // them toward each other
int l = 0; // index of the first element in arr[0..i-1]
int r = i-1; // index of the last element in arr[0..i-1] while (l < r)
  
 {
// A triplet found
if (arr[l] + arr[r] == arr[i])
return true;
// Else either move 'l' or 'r' if (arr[l] + arr[r] < arr[i])
l++; else
r--; }
}
// If we reach here, then no triplet found
return false; }
//LeetCode – Maximum Product Subarray (Java)
/​/For example, given the array [2,3,-2,4], the contiguous subarray [2,3] has the largest product = 6.
//Link - http://www.programcreek.com/2014/03/leetcode-maximum-product-subarray-java/ //The brute force approach wud b 2 find the product of first element with all others den store the maximum in the max varibale which would result in O( n3 ).
​​​​​​​​ ​
​ ​}
}​ ​​ ​
public​​ ​int​​ calProduct​(​int​​[]​ A, ​int​​ i, ​int​​ j​){ //dis does product from i to j and stores to
  public​​ ​int​​ maxProduct​(​int​​[]​ A)​ ​ ​{
 int max = Integer.MIN_VALUE;
 ​for​​(​int​​ i​=​0​;​ i​<​A.​length​;​ i​++​){
 ​for​​(​int​​ l​=​0​;​ l​<​A.​length​;​ l​++​){
 ​if​​(​i​+​l ​<​ A.​length​){ // addition of index is should be within de length
 ​int​​ product ​=​ calProduct​(​A, i, l​)​; // 2’s product iz takn wth ol until j
 max ​=​ ​Math​.​max​(​product, max​)​;
 }
  ​}
 return max;
  
  result.
 ​int​​ result ​=​ ​1​;
 ​for​​(​int​​ m​=​i​;​ m​<=​j​;​ m​++​){
 ​}
result ​=​ result ​*​ A​[​m​]​;
  }​ ​​ ​
/*Java Solution 2 - Dynamic Programming
This is similar to ​maximum subarray​. Instead of sum, the sign of number affect the product value.
When iterating the array, each element has two possibilities: positive number or negative number. We need to track a minimum value, so that when a negative number is given, it can also find the maximum value. We define two local variables, one tracks the maximum and the other tracks the minimum. */
return result;
  public int maxProduct(int[] A) {
 if(A==null || A.length==0)
 return 0;
 int maxLocal = A[0];
 int minLocal = A[0];
 int global = A[0];
 for(int i=1; i<A.length; i++){
 int temp = maxLocal;
 maxLocal = Math.max(Math.max(A[i]*maxLocal, A[i]), A[i]*minLocal);
 minLocal = Math.min(Math.min(A[i]*temp, A[i]), A[i]*minLocal);
}
 global = Math.max(global, maxLocal);
 }
 return global;
  3sum problem:
 https://www.geeksforgeeks.org/find-a-triplet-that-sum-to-a-given-value/
  Sort the array and then take left & right element from the array. Add this L and R
 element with the current element a[ i ] from the array to get the target value.

  class FindTriplet {
 // returns true if there is triplet with sum equal
 // to 'sum' present in A[]. Also, prints the triplet
 boolean find3Numbers(int A[], int arr_size, int sum)
 {
 int l, r;
 /* Sort the elements */
 quickSort(A, 0, arr_size - 1);
 /* Now fix the first element one by one and find the
 other two elements */
 for (int i = 0; i < arr_size - 2; i++) {
 // To find the other two elements, start two index variables
 // from two corners of the array and move them toward each
 // other
 l = i + 1; // index of the first element in the remaining elements
 r = arr_size - 1; // index of the last element
 while (l < r) {
 if (A[i] + A[l] + A[r] == sum) {
 System.out.print("Triplet is " + A[i] +
 return true;
", " + A[l] + ", " + A[r]);
  }
 else if (A[i] + A[l] + A[r] < sum)
 l++;
 else // A[i] + A[l] + A[r] > sum
 r--;
 }
 }
 // If we reach here, then no triplet was found
 return false;
 }
 int partition(int A[], int si, int ei)
 {
 int x = A[ei];
 int i = (si - 1);
 int j;

  for (j = si; j <= ei - 1; j++) {
 }
if (A[j] <= x) {
 }
i++;
 int temp = A[i];
 A[i] = A[j];
 A[j] = temp;
   int temp = A[i + 1];
 A[i + 1] = A[ei];
 A[ei] = temp;
 return (i + 1);
 }
 /* Implementation of Quick Sort
 A[] --> Array to be sorted
 si --> Starting index
 ei --> Ending index
 */
 void quickSort(int A[], int si, int ei)
 {
 int pi;
 /* Partitioning index */
 if (si < ei) {
 pi = partition(A, si, ei);
 quickSort(A, si, pi - 1);
 }
}
quickSort(A, pi + 1, ei);
   // Driver program to test above functions
 public static void main(String[] args)
 {
 FindTriplet triplet = new FindTriplet();
 int A[] = { 1, 4, 45, 6, 10, 8 };
 int sum = 22;
 int arr_size = A.length;
 triplet.find3Numbers(A, arr_size, sum);
}
}
  
 
